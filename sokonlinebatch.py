import sys
import math
import random
import numpy as np


conv1_weight_shape = (8, 93, 3, 3)
conv1_weight = '''恢径忬怛徽忦很徿怰忂恇待悙怎怟恙忝怖征恞忘悮怗徧悙忉悄忴怛彰恹恨彠恖復怺忂性彐恷快微忻徼怘怽忝忔恋恣恣忍彇恝徺恂忬怤怄忓恡忳恴恁忷恄怇恀忓忉怮怔念恴怛悠怙怚徴忤恣悁怚彿忁徰恐当急忀忄悗忄徣怉忁怕恒忧怖徍恕怤忩忾恃忏怅悂悋怙忓彴怊徭忦悛恣悃御後忿怜忶從怎怮张恨忝影恖恨恟志恬恗忰怭徭彟忶徜怓怌恆忆忹忁忥怕怟怏恦悕忡徟徘怙怶徹彨忞恁徴怜忦恡恮怀忉忏徺弾忮徬忎恩徤忛忮徎忉恕怒怱怔怉忯恼忋念惲恭态悚忒怕怆彵従怒怣徒忐微徶怠态彠恡徔怛忑态忙応影忯怎恮循怈彬忔忖怢怪怑怅怔怤忓怞徸忼怺忲恄怱怤怦徛忳悒恏徆恔忔怇怒恤忺怑怗役恐徶忖怣恇徾恷恊徒怏怽忖怽悅徱忢怶恃恘忞径忓怲忕怬忑怼怼忹忍忓怄怍忲怂忋恱忯待恾忎忸忴徯怵忪忲怖忂忭怗怗忛忛忆忓忻怘怵忂怃恶忽怙快志忏徆徚忬怲忱忮怇徧忡徒忏徾徲徨徟怎徧忲志怩忆忎忇微恖忖徣忄彘怑徙徽徑徢怍忴徃徾忞忟怜忑忛徍徘忉忺怖恒徬忼忳怔徨怚怎徛從忆怔忱彾怊怛忟怀忥怶忞恆忐忾忑忪忈恜忠忓恔怠徚忄恕忔忴徛怌怭怎徴恻怋徍忰徛恁徕怙忍忩忕怅徝忱恣忷怈怯忣徇忬忍忋恇彨强忢悒忘徒忥怂怜怇怨性恻忋忇快急怞徣怆怦恊怴忽徳德恊忲忢往惄忈忐恅怷徺心思怶怞忡怋忝恟忺急忔忝怮彾怏怦忴怊怵徦徻忧忓忓忏忳徠忛徭悄彯徍怹悷惜徝悒忍恕忘怒忋忭忩徍徸往怫徼徦徺恷忮彾忧怙恞恈徶忄恲思往怅怌恤忻徦恫忄悴復恵後微德怀怕怌忟怚忸怈徺怰忏従徾御影忩怒恚怨徃悏怋忿怔怏忷徔恹彠怷怼怡悮怹怃弍悢恙悉怭恲悔怣念恠恸徴忤恗忎徺恷忛徢恡彧徵恞怮怸怆怜怙愠彦徤恢忳從悤怗必忷徔忄怲怹悒归忌忥恩忇恂怿忣徾怊忈志忔待怊怙息怊怀忧恊恷怳怖悒怙悒恐彬忥怩心忤怚怯恚忴忷忓怨忾忹惘怉怋总必徥怅徶忧怾怹怢怎忂徸徘性彺悔怔悒恬怔徛忕徴恰怸怼怕恏忷復怘怐彤恄徳怾応忀怜彽忺怾忋忷忴怖忢念念忶怶徥徭怋恛怀必徰徰徆心怛怌怡徠恓彑徹忞徜徵怊怌志怃彰忥快怖怞忖徸怢忚念怷彨待怓徑怑怨怋徝怲德忥忣徦怼徸思徆怕徾忍徿忂怐怀徾忠応徰志徰怌悓恼悢徬忈忳忸怖忩怏恃忆怖怡怗忒怹忆忽怀忣往徹彐恧怟徢怀忎怴恶忚性忤忰必忲恇怓快怕惴忻徾怌归忥復徜徢忲念怪怏忾忓忊忶德怺怄恨急怼必急恔徜徺悓怟忙忛徊恡怍彫怬恕悇御恣徰悄悘徭怫忓怼忨恣忲恇悙忈怗怸惹忯悉彧恭得徺恇忶恨忁忘徼忆悻忰徽忈忘恅忂怾忶忊彁怶忯得徿徿微总怭忿怺怮弞恞怎徘急怌径忁忹彧忱忺徾怈怳怓忐忄怡怑怃怏忋忟忇徰怕徿怲徸忼忈悃恥径恗恂忖怟怿忇恈忭念彜忐恦恙怀思怨怲徸怕怤恇忳志德徙忘忋忛怜忉忺忴怕忿恗怛愗怳徼恉悌彗応怏快怵徨悋悃彰怤徚怱忛怣徘怱思忶怩忥怕恇忳得從御徦微微忔怺怄彶怤怡德彝忏徘恊忨弛忭忤彎怈忲復忪悒彁忂快徃忤忭忐恮徶徫忑忒微忸徭怵忕怯快忔怯忤忾徾怯怦态彵彺快徑忁忳忐徽恍忆忪忒徣忥徨徶徰怒怛怿怆忹忡彲忬思恂忠恓悁怏忆惠徝徏恲徿忢徱彻怙徭徬徯恒忹御志恝怈徲徨忟怌忏惆恔弦徚忛念徺恻恐徰循悃德怓怟怶怀怜怏怶忰忡徾心徶徧忹必怿必後徳徧忋徘恝影怢忲恆忬忴形怤恥彧忷怤恦忒惑徟彽性徨忩恙悚忌彐徙徖忇廊忹忐忝怗彊彶怊恘忩徏总恴忖恙德心忖徖怳怴忚恁徲徱怇怰征忋忲恤忺忆怫忄忲怛怹怿怫忒忘必忂怍徬怳恂恇忳忱徼徬恁忚忠恛怩怹得彀彚彿恽徱忨恱患忑怃态怍忕忦忢怮怉彐徍徣彽忓怫彿廴微忠怺忓心忐忏恘怐悄很怉徒徚徖彭徇忆忱復忒性怠悆性徭恩怃忨忁急忏怢怂徻心忦忽徿徏徫怩忳志徠怘忀循怒怀徜忈徳快怂怙忋徼怟怄恦御徵怹徲惰恢忺必恑弧怜怢怍恄忲忍怊恫征徽忷恄恌恉忁忚怛徳徾怅忣忿急忆彧怟徦忌怛彶怒彛循徾怓彖彷怀忝忇忨忮忦忴忩忂怓徿怉怦往怄思徘怐忔怜恨恶忘忌忚徿怐忉怕怄快徯心忱徑怄徘徲忥忺忒忓徝忒悏悇徠恹恋彶忘徿律怾怒徣怸怟循忌忻忈愂怡忦恮怶怆忎思念怌怉忹恮恽徥徬德徘怘徬徼志忝怜念忇怱忡怡恗怭彮忬怽悋怣惌忺忛怕徰怩忶怔忼忐忈徯彿徜怅彸怏徹忋微徨忍彚怷怠忐忱忦急徫忎忾怰忰忸怐忰忆彭彸徂惗徚徆怙怷忂徹彷忠怀徘徫徿徴忭忯徠忖悫怉怄惻恬怲徺怶快思态忞徼忛怠忄徶忘忭怆怒徑忈徫忐忯怯怛忦怙忇怏徟忠復忝忢忽怘忧怠忲忞忠御忏怈怰态忋忼态怋忱怎徺徶忙忸徣怊忽怪従怈忥怖必忠怈急忮怦怏忞忑徑忦怮怦忲徹怦從怜徨忾忓怴忖忍忺忞徻怕忸怜态忇怫恂怃忲徯徎快怱徐徣忺怦律怅思忳忮怒忹忑怵徺忧怌徢怐总恔忖怬忮忍恣得怷恔忦怤忉忁怢恮彯恔您徿徠怉怆必忻怘忲恘恥恵性怐彞怔徸性悫忳徯怛念弦忈彼忺悍徯念恢怏弫必恣怊恀忯忟得恚彇怒廿怠恗恪忠怠怲徣恏忩怘怎志怂怯怸怨怶怸恋怰悕怇悞恮忟恼彽廤怋弒弲徤忐彍忔彂復徘录弙怩怪弭廼忻忂恉徰彵怙形徙怙廿弅徿弿弎恋忓彝彅彑徭怃彄弟怕律弸怈徉待怱很彤悂性徱徟彯廿怑忟彨恄彫弮忺忾怖总徻怹怪恄怵忛得彬恙彰弸怘忌彰忊徏彷息彨往徏復彻忤彈悄怔忝恛怖徙录忂彯恅忍彼忧恩恹忢徐彫弴恛廗徑必忽当忦彮忉怩彐忠怿念彦徆忥彶徉彠徏恣快彤徱弞恅恏復怟悑忉忧彾怊忿忖恆忣忒怯徺忽忚怘怕彧怄忇悡忂徇怢怗怑怏忘待思怬恕怆怲怓怦恏怖怞怶忘徾彥忡怃忺忯态快怘怣愅怠悍怨心恿怏惣恂悝怨恄忙忼忚徳恁恩恖恫怴怿恤恺恡怏形恅徢忾忍彁徽怡忙徺忧忐怭忂性怂忭怤怾怣恌忮恽恫怦彾恙恟忤忥思徻恓怕怌忭恰恥忑恽恔忷忒悁徲怇总弭悖忚恚忏怠恐怋悂怵忻恈恑徤怬怐恑恍徦恂恉恥怅恩忀恑恬恌恨怞忨怰怬恏怑恟忝忈怓怀忉恣忛怲忹忂思怩总怦怘忥恆怜怒悏怒怄恊恰怏徺恞忝怩忪忉性怃恟従怺恱忮忎徰忻忟忀忋恁恄恶怴忖恰忟怌忀悈悤怗忹恀怙忙怷徢忘怵恣徬忆怈怢忇徻怄悘态怍忖怪忋怠恌恩悚忌心悳忔忉恜怶快忐忺怚心徿怩怀忙恤忳怮徭怆恈忺怆悍怡弢怬恌怟徦恎悍恣忋彖恠怮忻恢急悋忼徰徾忠忔忱忆彺忂怣怇弲怃怨忟恣怘恇恆忖彗恔怀怴恙怾怾怵忛張怢怔怳悌恔悠徬怔忣怪怐悄徺徔悵怽怒忎忂忷心怠怩怖怣怛徼忲恠恎恜恮怘怟怛怨怵徙彩悹怼忖悥忙怨怜徍徣恕恃徳忈彡忿徺彔徦怠忏徊忬怊恾徂彷弴怅恖張快忷応征弮弐恪忁廣恝徽怞徾彺彌怞徤彔怒忽徒思恛忑彋怉忨忆怩怃忕怞忆怨忬怖怢忳徳怌徎彛悸得彂彌彴彲怛怺怡忴忰怟徤忮怋怒恉忪往恒性忷彼忀忄怫忈怪怉徻弓強徯怬怭快忄怙待弴強弝悀悏徍徑恚忣弩徰律怑怃徹徠忎怨忷從徫怰忘忏弰怉忔忢忆怶忽忺徽怙忛怌忈彜徕怹怠忳忘恕怦忿忏徳徯怋快怏恉怖怒怲怫忏怏忶忸怒怽忪恂恄忪忿怈怜怟恔急恣怌忎怤忹応忁恉心恀忷忱怐怯得必忭恂思怄忠忿怖徻徔忾微怱彍忒悎怐恐怹恏怸忯怠徾忱怹忖忨怶怶恚怰怌徽恦徣忹怃忟恛怸恃快怟恌悗恍怆怖待彻怪恗忩忉恒忺性怹忶怮忣忾怌念忉忸恙悎怅徙忱忥恻忎徖恎恃彵怴怬怽恇怢徽恁怀忉徝忚怛忨忘彻总恲怙忇忦応悇忢復忳恝怢怰悮忷悔徱怵忠恅怴徽愋惏悠徿忖忽恶忺恇徐彷恆怺怾忖怃怍徾忡忓怣徽恸忮恼恒彖急恳忣恥悤怈悮忖悟彶忞忏惈惯恐惏忨惁总悠徼恲徖恣循怅怑怓怊忯恻悉恈悙徹悘徶徸忝恰恽忒忪徠怋怐徣徖怂忍怑怊怈忟忽忁徿怴悱忠怸徻悌徴彮徼怉思忯応急恆怱怃忈徿復怑徴微怉怊忙彛忯忝忖恨忍悃忄徇忻徏忾彷愺忸恪彑忞徨徤怯恎徴忐忥怚怱忎徚忎彿忓恄忠忠徦忩忂忟忻悁怎思忦徊徙怪悔怲恹忂忛徸徣怖徦復徍恺恶怨恬徯忖忔怩忲忐忠怟态怀怀彉忻忹徘怎怘悉彴急恙怘忓怄怒忔怤徦忁怠怸忢徥怘怠忖忀忭彿忪忊徕快忯徦弮忑怯忰忻恋徿怭徕忣恠怊恁怡徵忔徟徍忼悶忓怜忨思念忇忩忛忤恣恴恚忙忰怕忏态悘怃怱怍怔快忋怓恂怒忲恌忳復忙怱徰彶忔忲怤忭忩徘怬徐忪徒忳怋忩忎徖忪忕忐径彔快弿徂忟弭徑怽忻徥怄悆悙忒忲怽忭徯怱态忷怒徵忘怰快忕徥怵忢恫忰怔心怓忘怿恟恪怆忣忇忼怑御怡急忳忨怺怘忼忁忽怛忶徠怖怆恗恒怮忸彺忆応忾忎忼忯忁忚恙徽心徾悶恫态忧恣徦忉忩忌得怞忪後恣忔怨忣徻惼怘怳彶惴徱忏徎徧忋恀怑忙恫忷徼忩忇恉怐恰忨忨怽徙怿怟悪忈後怱怄怒性心忘忄怿怸怑怌怏忓恄彀忆怩怬後忎徯忴恱忶恗怬怏忿怄怷忥怽忪忇忕忮怓忝彵応忠徒怙徭忳忊忯恥悈怈志忎徸徴徦怖怄怠怄彻忋忝怪忭徻怳恫徿忘志忨徃応忐彙忄徸弴徹怆恤徐忆忞恄恆怭怮忛忭怛怡忴忩復怎忐怳微徿恗恔恛怇怗急怳徹悰恆怛忼怐恨怗彉德悹悆忸怈思忤忓怣怭怭怯怌恅徬彗忰忹徜恧悿忤恚忧忲徫徬忔悐恷徸恻忖徽忍怏忂惈悡您彈忉忑悡忮徨恧忹怀忑徼怞恂忧怾怹急徲忳徕彿徙怤忷恝徻怱恀忂恚怨恃徢恪忕恴悼怂恧悍忦忓怍怢徠忞待怚徿忏忎忯怅怠悝忯悁悂恇怶忼彾恥愰怍恺惁忦徕徤恖恚惂忴悟恱忚忲忢忎怇惡怂徹忥怤快忀怲忱怾徻恃徿怅怹忸怒恡悡怃忠恍怨怰忄忇恍怠怐徵恤忶悃怓忙恱恚忧忕忙忧怶恜怬怢恊怜復忩忭怢応忠怆恆忕德忑徟怏恙恬怖怞忐徱忑忿忇怡恳忹态忺怨怑忪怗怍恅怽怖忿忮恥征怲悒悍怜忯忨忔忻怇怓徼忙恠恐忶徼怕忊德怡忬怃応忌忇忮忧忎忰忹微恕怰応忄忦恚怒忹恕恮怛恆忶忏徴彚忲忼忞忘恈忄忱徫徐恈忄志怑忶弉微彙彌徆德忎徸怸復徭得彫循彳忌怢怷忘忉徦彋忴徳徺怷怽忑彝忁彽徔怫忭开怇徆徇怇彸悐录忉怹恑忦忑徖彇怈忦怸怈志怎忢怃怒忺征怎怟恺徴忦徛弴怈怴怴必恂恛徙忺忴快弳彬弻怍忤徽忓忬怕怽恩怬徲怣忎恇怀怛忢徯忕悖怆彀彜忞忶忰影弨恪悕徫急微忼怊忢徂忴忓恢怒徰忣徼忘忎恡恦彻怞忹徸怅怣忖忛怆忹怏忢忖徼徂徳彺怖徟怯怦恆彄怅怍怑忇怅怾忞忣彏怭怶怯忶性恃怵徼忈怃怴忒怛忉徨忤怴彫忎徧従忟復忓忛微徲忰怣忂忔忟忶恌忳忓怎応怯恄恓态恽徺彚忕怆忩怡忴怙怔怆忿怍忀怹怶态怺怵忓彍忠怵応忪怺怨怔怆忟忙徳怎怕悶恅怕性徤德忻忲徧悬怉忌忊忿怕忡怒怃怚思忣忶悋怨怫待急悍忬徙弔忸急忂徳徬悯怞彻怦悒怱怎彭悘恲徫忦弞徧必徊徏怃怠怾忳徥忙怔忄怞怛怡忍忿忴徾忆忍徶恓怵悊怰怍恊忝徂忸怶忝忣怃怶怌念恆怚恑忁怅念思思径忆応忒彗徨彣念忆循徥怐微徾怀悋徢怂忻怗怴怈怸微怫怚忰怢微怋悉怼恥怳忋忙怇忣忄怑得怍徲忓怟怄怌怈怃怩忮怾忡忌怐忩怯怖怅忊怋怏征忿忞徫忀忪忼忁忀悸怆怠徘忺怈心怾心怷怙怬怌忩怩恮恘怄惰情弻忭恀徻悁徣彷恝怄忑异怏怚怢恬徠怅恖急徴怲怞悓总忁恟恗怃怉恳怋悐怑彽怄忢忠怠怓忐怖怸忛恇忕悀彉恤怌怪忉忚怟弟恋忷彍彐怳忥徉恼彚忏忐悭怫怖恟忘役怇忑彈彐徳徻忎怀恓彯怏忢悈恃忸悓従忮彽恑忇怈恀忙悟微恎徚恆念悤恼徧悁徨從彮徊弲忾态必忂徼忳怈怕怖恃怏忎怜忰忮形忳徔恅悐忀悅忀恰悬徻忬忁悆彶怬恁怕忍忪從怷忝得恙惩徃忺彮循得彣徰恉徢怒恇徴德忈恗彼恏怼忚徯徎徴徔徛录恓忸忣怩徍彤怗怀彐忰徲怯忣怽恅忉忩彺怡恗忯忪忋忇忬忾忈忤总徘悼怉德忖悴彼怫忉徼恔忛忀徴忘忿忒彫悝怶忻恩性徑忷怲忻彮恆悽忾忍忽忐忯忺怺惥思恎怘忭忚怒恣怱悟恮悵悌悉悸恂志悎怽忂恏怨怈怐忶怭怗悇恰总恃怢惜忎徬怗忽必恅总怢态怷恆恝忧恉怑忠怷怐忘心忻忥怱悉忉恆忚忤恢怗從怱悓徢怸忸快忼徻怉恋忴忺忍怗徼忷忽态恋悓徔恛怫怟怘恞忩怙急得恣恇忡忽怣忘徳恂循怭恜怣忘忣德恲忷徾悎怜忑悍忰忧忣応怢怖怰忔忳怀徽怪怡徟忹忪從恣怞恀怋恿怏恔怜怳怵怰徯恵忪徎忩悃恬弥悞恁忤怍怕怲怒怱徕弟徏快徬怿悄急彣徤怏弨悏徯恱恵怑忎恄忢忻忏微徼怪忍彲忬忈忼徰彿恰悯彡徧怈忯律徾徘恨恻忲彖微怚彧怟徦恖怭彵恃怾怳徐徿徱恁恚忼待态性怫怯忇怄忊怳怜忤忟恪彀律悍忩怅怳恋循忱忘忀忶忒徖悃忱恏忲快怙忤徸弱恏恖忧徲徕忓彴怏忣忝快徫忉德思忴忿徊怽恟怸徶徆怐彮忴彆忮忣念怋徳忺忒总彆悋惘忶忏忆忕徝忘忥彪彭忔忸怱忪忐性怼恄忎廌忼彂恤徛怯廹怤恱怃忌恫彤徹忂怞忑忣恝恑忺彐徥忒恲怃怐念怦忇怐怸忩徾忩怇必怳性心徬徼径徨忬忆忽怸怘怛忕忖怲念怄恔悬忍忉怦悾忘恧忊忪忍怆恅徚怯怸忄怦恂怊忾忟快忸忊忆忠徽忍恎怵忶怱徳往怀怺忧怤徙怭徲忣怋忺徍徛恊忯态徦忥徬恷恄怟忎徊忐忔惓忰恡忼忈徿忱惥忙怫徊忒忁彮必徙悎怠徭忟恐徾徺怬徂怋怟恤形怶徚忿怙徽悤忶忇态忘怒怯怺忥怭忀忀忱怖徺忈怔從忹徣忺彼忰怡忮忁徤忿徇忰忏怚怞悉怤彺怌徬怟态怇彤忢得怙忉怤彦忽応悏忹徬徇彯忮徊彪怋怵恌徝徸怀忾怑忨徻恮忠怀怱怴忬徠恃恡忀怮忉怔思忬忠恂怀忸怾怘思忍忩忐忲态怠怦怤忷徸忸怠怶忞徬忺怑恚彲忟恏忛忲忦必徨忌徘徇恹忾徃恁忺徶忆忠怄恌徭彺思徜忙徕彘徯恰後录怇怍彻往徬怦忡忹忶忙忝怅怀怦忬怤忪得悓彦怚忢怒很恰急怛怿恁怣忝忴急怱忌忤怌徟徣怇彩忙悈忦從怈怡忂怷忦恁恋恸怜忸忄忦応恍彷忭待忌怂彺当悊忍怬恮恢忮忹怊怇忧忍忽怞恙徏志怈怌快恪徛忔悀忐徦念怷怫悈忐忤忨恡往忕怏思悜怘徢恧怤忆思恀怛怈忎忶怓怹彻忮徿徾忂忥徍徼徯律恴恀恋怹惌恨忷律待忻徬怍怿悹怛恞彗怍怃必待恻怢悂恾徴忸患怐恕悻恺息忹徘德怺忽怼悉恷忲怘徉徇悍恑恉惤恔恆恧彴忭忶恉很忪恢悞念忒忳徽怠忞怓怶忕怑怏徽怳怤徫怛当忝恝悋总忡恱怑怜忦彰徶悁怩忌怘忝忼怚忕恑恂弲当忡怔念恘忧怰恝怌怒忰忣忥忦怎怫悭忨彳恨怊彷怐恤恺恅怖徤怠忈忟徱怍怏忂徍徉恍怹忻怀悭恅怼忟怓怆怂怣徺怅忕急怤彮恀怰徶徭怓怚怃徥怜怫忄忟忿忦怷忻忺恢恹怌徿忘怆微怟怙徸怐态徽怄忲忔忔徵忽怒徤忂忰怃怘怓忿怠忤忨徯怙忹性怌忍忱恑忠徽忆忝忱忳恶恶悱急忺恸怂徬怶忢忮忤怾怎忾忭怽恂忽怀忢循忔徫徑怣悇怴怽悂忓怨怊徙怨忒忿怟怐怼徧怳忾怟怰必徝忚悅怔忌惛恙徟彴怴悱徉忎徘怏德忻怳怳愇徲忲忸忚怠微悆忉忊忤彶忓志忕徐悱悆恒徛征怑得彭律怤怟惏彰従忰徳志弌怱怔悃彗忝從恔御徚恱恃怢循彽恿怜徔怏怌怯怪忖忕怨急忲怂悳形忔徾怆徽怑怪忓怀忷恐彈忮徿怒徖悮忾怿总彔恠徲怚從怓怞悮恬怡怵忍忖心徢怦悖悛念悂忙恗恌怖彅怿忡忔恚徰忰态忷徛怫彐怋恽彔徑忇心忺惑恣怆忟徏怅徴快怴怾忹忆志徼忑怗忩忪徦彦怀忘弫弜彭恛忇恣恮怂忸徸怾徶念怂恴恿彌悐徒恲徛徻怱徾忢性恍怆徔怪怄忀怘彧徶怯彖怳彐忿怓悙惁徔悙徚恂徃悦忼怠怖後恼彵恷徉弤怰惧恼恎悎怎怾怐忇忧怗忴忳怟恄怙忑怡忆怃急快怕忑徟怏恊恖徼忰恾悦忑恘怿恜恱恓怰忽悶忛忶怞徱态忤徱忢心徶徒徵恄忠怟志悑怕怔忚悴忣恰怹彴怔恏徲忦恢恝恌恄怨怼怔循恵恵後悂态彣悆怋徒忔悈怣忲忿怩恃忶怋怫忧恗恩怐怷悋怄忍忓急怛忩忟忐忄徒彻徕彜总恕忭忿彫徥微怋徂徯很彾徫忋忐怮愀恐恠惚忱恨忑彴張怿徝恐恹恏怡忇待彶怜彁怜忝忦怿怒恤徸忥忼恪恟怃怣徉徘录徝彯怅忊忼忌忘忰忱快忊忹怬徿怎忘忻当怶彪怑怳怺恩悐怀怰恲影徤忑徺怱恉怃忟忍彅徯忒怢怱徾怢忁快忇怞忱忀彳律徰徻弼忓怴忓忓恟忭徭徙恮徂忈怡忉怺徂循忼思徱悄忧徳忩忎徙怖彩徬忀徼怌忱怓心怐忁忆怘忲思怓徹微応悔徯怵徙悭徬忍怠怔怦恬怠徨忙忟忿忂忨怅忰怘忽恆忕怠徒徵忸忢恐徏忨忒徵忩怭忀徤恸径怈忉忖怙怃怘怆恒忘徙忣性怞怇忉忤恾微忇怙恾彖恖徱彇怪怦怟忓心恁忲忨怭怞怂忼復怱怩性忷忊恒忸恚悿悿恦怆忊怤忯怶怅忂怄怂恊怚徕惔怢惟忟恆悏忬必怲恬徵恧恈性怟怶忏忺怀怉忿忪徾忋忦忄徝恆怞恅悅怕怆徲怀怌忡怋徽悷恉從忇怌徚忻忩怴忤怢忸怕忰忙忈思徭惈恙忊彥徸彯悵忁忠怜律怮怠彪忈怳怹怄徴怈徼怭必怠弣怯忊怌忱忂怏忾忴怢忶忠德徽徇怎怑忄忆志彼思忒徹征徲忮恞怞忠忷忞徲徐快徶徒忏志忓徝强役徱怗心怔徾怳怷忉怉忺怟恶怣忤忠怛忖循恞徕忬忽忶忧忯怉恪恗怯怅怅怣忧忾怃怕怳怞恃忴忶怘忮怄怘徰怍怈忓忬応忝忸忬怎忠忣応忱徰志性怟怠恔忏忡忰怙怣怼忎徹怏恙忷忟怎怓徣徭恕怿忦怜怓怚怦怾总忍忚怳忢恆忚怱怔忆怍怙忒怶恩忾忊怤徉御待忒忱徾怈恖忘徰怙忩总恙忛怡忏怓恿怣忱徏总怒怵彌恛彾徾恓徤忞怢恣怞怼徥忟怇怏忎忌怬忎怤怐恗怛忐忪徕态忬怊忚忎怎徦徿忖忶彡恀忦恷怦忖怙忝怀徶惞徕忘恍怿怵忺怯怰忶恬恙忢怩怬忡忴忦忇怪怢忝忆怹怦忽怙恶悆怾德恊徦忰恷忇怏忻恁快徻恵彔忇怗彩徇忟徵徱徹恈怅恝忚忂怴忁悊忟忋怘怦忰忝恸忞徲怪徨怞徶忿徿忄徵怒忩忋徣恺忇忲忲忁徸徖忰怗忖彐怇徼徢忯忳怫忞怺怔忒忨忏念徯怘怇忷忳怫恦忘弚徹彑弴录忏忩忆必怯怦怿忒忋忄徣從彣忶怱彠怐忀徎彭徣徝徂廫弳怌怎恛徝後怋徣怸怄恜忦忞彖怞律忖徃忂忰徬忘当徬怲循恞徣徹怡怶徎忯弸怅忉忒怂怤怀念怾怭徛徠彧恣彨忒很忻忆怳恁心徭恪恂怢恎忭恋怆念徟恕恡徦恂怯快忕怮忔彷怔徰彭怗总悍恄怄恶忩忽恍恖忴怊怲徔怹怔怓怄忼怗悤恌忾恰忾忞怾忆忻徬怍徧忉忦徿徧怄怂怛怷忊忩怒怂忄快怔怍忣忋恀恋忎忮怷怡怐忢怑忶忤忌徣怙恍恝恆怺忨恉怣律忇恐徯恼怈徼悌徣弹応惝怃怀恄怑忘怓徶忏悕总怬怀思忌忀徿徭恲悒怈怢怠怸忴徠忨悫怠徿從忣忠忍怖忴忺怜忛忋忄忞忨怳怂快忴志彾怖急怛徜忥徟徭怑徆徽忤恕得忄怉怶忾性怩恇怕怬徴忟忮彔循忋恋恺必怤忤怔弞徕忒怡心弤徿恍忡徃彺恹总恒忪忒恋恂彙彐怲怏怦徺後徠怒恦忭恇愀忡恕总怅怨性忇忩怨怛怼忎怛忞忌徖怨彬怗忧徥恂录忛念怑徧徽怬怊悚怃忾惏忤恠忿怀怯忧忒性态彿徽忚循徣恨徳怬悐性怊思恈徻恓徣恈悕怿怩急恍忤悚徥思悊怯恒怼恓忽恟忙怊恥怺怵微忰总忆忠徺忿怽怳怗忈忻忤弳忥忿忼怺思忤怆忱忏悇怭怷怵恖忤您忶徶怈恇怡怮忏彖怇恈忯恫怴恥恼彘怂必怴徭忹恗悉悔忱悈怜怔徴怣怐怯怴徎忞怋怏忶恮忺恛恻怉怡必徯恒忋恝忻恏恖怆怱志忝怌徾恄恅怿忯忊忕忭怍悐怙恌徹徼恨恞恁忝忞忀怔忌彝徟怨恛忡怭徾怫怦忙怃悏忹怮徘徿応徧御忧恀怠忹怃忒徧怭忮徫恝怺归忙悝徴志彰忦恈忤怏徕忻忍御徎忝怅忄徧忞惀徫怃忝恚怿忔怍忹怅徺忷怍怎总恑彬彾怇徎忄忞怑忞忘徾忸役恲恼復怑忘忾怏忋從怵忳徽徰怃循怩怊忋恍忪忧思忼忞怆怚忊怆怇忆忬恃忣忉怌忍恓恹忶徴忘忿徻怡徨怄怺忨忱恞怖恥忡怄悁恻悑怪忭怚徹忈念怤性恄怿怘忓忡恈心怼恤怫怚怰怳怪惐怶恄恙怾怹恨忏忈快怦怮怶忭忨忌怡怙弽徻忁怖怯怌'''

conv1_bias_shape = (8,)
conv1_bias = '''忌怣徦怜怔怉恛悧'''

bn1_weight_shape = (8,)
bn1_weight = '''柏栉枒梐枪栳栢桾'''

bn1_bias_shape = (8,)
bn1_bias = '''怂忰徶怶忑怤忰怟'''

conv2_weight_shape = (16, 8, 3, 3)
conv2_weight = '''弝忴恇忭忣恐忢惦廍忬彵悲廩廓廤惆愁归怳彮役悻彰惹従往惐悹徬惊恩徾徃恾慌式待恂惙恉恟彯怸惒强愑影悎怯忊彊悂惉惒愁惿恦徼彯恎徺患悘忲徠忠彏循恶惂忑惼弑怱怑恋怓恹忉弈廘彵怃忕忆徣忦彆彟愛彸徵忩悇徔怤恆怵悜徿怘恵慫愈愛悾恷惎怈怑悯恡怶彉怙惎怋怬恒恦彃徟弄忨悽悆強恤忎彂忀忂忽忯惞恻彴忇怣悼恬惕恠悉恉恔忇悱悙怟忔恨恅彚忳愬怰惋恩弣惲恩弱忺怹徶忀彮彡徸怅弣怙廡悙愱悐廲弐悕惗患怪忼徕彎怿徳廚廜忷恲怜彴怢惐怩弑怟彭忡忎惹恮惱恥徻廤彷悅恶応忕悿惼忏恧忨彿弹徦忠忁愗弳式得彛怼怇忥徛廔怼廩彟怠怛忖悜悊彸怱弈徳怕悩悜徎悭恂怽彥弗怬弃忮弗忩彲怌恌彎徠弄忲悬悌忙忪忉彀往怕惐悾忥惬悏弡庶忚彟廰弫怨惻徢弩徧总恪忒惲忍怚徆怨悰恹怔恵忊恽彙思彐廰弘思徂引怩悲徯彂悄惻归徤徂恬徖影延悧愘廾患恴彿忧弖惯惝惡徚恙忠形忐恠志恽德悄徎怘弓廈悙惪悭彞悍彈悔弸弚怋応忺想恎弁忲悄彂廡徝恥廩惣廥恗怛弗徂愍忤惡怟彴怾悉徖恊徔忏忚強忣彂忲從庯息形徇忕恴恐恏徬徤慞彇恱惬忊惏忊弓惰恍悲弑忖愠愋怑弰恢忺恨忖惐惔恏忔彫忣徖怩强忆怡徼惔従悧怼建恫恰愣怀忦当恐弜恥恅恗忽愻弟徏悲怒怅引患恀役怢怗徵彩廎悑彟怸悀彋彜弯怠廫惲彖従忀恐徣必惾怱悚忟悈悸忢恊彀廯廛悭廪弴悜忤彐愱恥怣徛忕怓怀徊慘悴彮悄恳徉忦恉徿彠惞悥彜忌悐惂徱弄归彣恷忝弞徸徱恌悅徵彄惄惦徟怘恿惟悗恹彯惏惂彿忩恵引恣忑弿怱悔怔忧悮怍徝彧怌惐悙很悵怫悁惏恕怋忟悅怞忝悫彶恐悑弶彛悑恧惥恔徂彵怫怢忺忒彅復弤强很怪徑彳弯惸弪忌彜忍忴彨忐恤悍廤廾徬廢彝徔弱忭徸御弈惖弎恧恰彩徯弳徢彊徤忣彤惕庎彐必恔廔徢弍患悡彸愒彂忥忬怆恱彼惬愷徢恼徔忩恜弐慎彎律弟怸悷廗彿怼忢恟悤惺恐怆慆恤恖弔怏恕徢忭弟悽彝恡弄悤彈悛悖式悟悛彴怒彊悸恀怵彾恵徶惜意悐彣悅恤强彳彔怂忨彘彑恀忦怰悔悆恅徱恾弼庚怇怤怍心忍悉徦悥彬怓愳惓愊徾惋徘廣彆弁悄恹徻強忭怤恩彳悲忽德悜弛徵徎愎恡循怳徔徊張徝惮怳彾恄惒悉忈弶恫恺志怮慍悰忯慜愙忄恈态恊怙彞悯徙惍忑恥惞恢徚恌愛怠怷悤怶悙弶忍恞忷怋怡弁惘怲忧忍徔怬彦恺徏恒徃怹忲廷形怽微忉悖悪弛廾怼廄彥弟彝忉恃御弼怈恢弇忻弝徠弯忖怭廓弍恐徽得惯廣彐患彰弸志悾悞惎忀怫彙恄悃总忇弟彭彚彈形弛怯怂怾惞悾弫忎惱忤恺慀恂恐惼廿忸忤恁怯徜忡忠怶弫徿弚怭很恳律弤怺忾彭彸徴悇弶悄惵忲怎弒廪徳忦恽必徐恻悂忬恂彻强忓忛愪愵息悐忕悍悕悙慎忥廙忆廴弚惮従彛忠怿悬弝悰彳徬怈愒愺悥弊悴徉悩恺忒忼彴惭徦愭悙悻徳悅徲彬息彦忳惤惃彻悮彖怿悲恺廧恅彁怷彐悪廿怄怇忳悌往忩廽徵慔弉愴恹忈徖怨怅忔忯悗後徏忝徝怚影悍恆怚弣廠悮态廛怅悡怼彩彂悬忾彿徱怋徍恤惟忤悌廆彭愁廠惏惄恘忐怳彣徃徣怈彝忌弬悬怓怢悦惔怷惯惪弢怪廥徿悬性恩忉忑後悘怷彲急彣悱怱弝悞恕弭念徟忏怯怉忲忝廪恴心怺悒恟惭彀彲幜恔忞徯径恙弘开徹怖怯悃徬悍彳徲怆忟恃惰愿愋弉忊弧弚弒彚悮忭悦忁忬徕彡恧忀'''

conv2_bias_shape = (16,)
conv2_bias = '''怎悀弳悱弜怼怡忑徭恀徆怕忏弸忄恷'''

bn2_weight_shape = (16,)
bn2_weight = '''档桁栢栝柑杼柕栯柍桮柀柬桾柴枧杼'''

bn2_bias_shape = (16,)
bn2_bias = '''怹忒悁恖徽徃徣恜怐忪忽恏恖徢忠怎'''

conv3_weight_shape = (16, 16, 3, 3)
conv3_weight = '''怹悯愓彁急悹惈徠忞恁惋怏悂怽忨心彴彇悸怎悺惮怮怼怹息廊恀悉徝忬怑忲怙彄忽怴怜弫忌恼徿恒惑徲徢忦彨恩怃弥影悊怛忮後悙徔悊恭徥忇悭怔恥恘怺彻恈徃恏徼怕彰徬怅彟怳彽怜惃怩役悊怱怩悎徬忠徻彺徣恹徇恡忷復彿忌怌徱徾廝忟悡怪徇悎怇悤悄弙徺惲恓往悒悗怎徆彼得恱径怇忯悟忁悄怖怍循悮怏彏彺徎恶怈恑慈恪忮悧恥彄従彘引恑彻忣徎彄恧怄忢怗彌廦彳忍恾彟怴徍忔怄怋恘忱怹徐恎愙悆怮恗惤彮彫彾恼徏廡弎念忑彞彨怭忽怊弣忙忤征悅忍恐彤恲徳忮忁忲恈思怑徜忇彚恄徻彥悲徻恾忀思悇徱恽怮惈復徟恁怬怪悖惁悙忮惉悖彬怉恶恝循恲恪怨恃彐心恹恎徳忺徜徹恦悇悡悏忦悽忷忭忕忥忓彝彉怍恁徒徨彲怏忷恕強徲怱廈惆怼怳忤忴快徸怔徬後怃弹徚忀忍徛怲恤悂徔怃忇弗弬怂彾引彰建彀弽志怢彛忨徊彵徐彽徖惖恢彴悱恽弭恸恱恤忛性惬徠彛忖忻怿彲恚徿怴悇悝恻徹徐彣性悇彔恙怛彝徜强従忋恜悅怞彑廾忼恋彏悆悬怫恜恓怸待忭怑忬恻怬归怊忳徖恈恐忥恛復恆恟怈応恎忈恺徜心怒忬彋怜忦怠惗惐徲忙怞恔悧徍忥忖彐快怬忄彨彥忺忦忋徲徙弡弹怕彖恒恥怷忘恍径徔弳恂怒忷怡徒恿忀彤悌徴彁性弽弹忈悭德忆息忌徶忞彙忘徰忢徹恖徣怃忑彁怲患忽忑性怗惄徹徫怋悤徹弦庢徱徰必徾徹徴忔徳愕忇彴悇徳恚悓徘忥径恂徹悅彦恲彶恙彺忄恸怑徵微徳怀怿徿悥彔彂惓忐弯惱悞悬彐怗徑忼徊彽徯悛恻悛怳忴怶忾忙悦悊怬怔悭忥患徫志惫惥心怅徜恣恙忓徳徥思忧徃恨廸性恣弾忭弚彗怲從徬恍患徶悜悽惉彙忴忑忢徕忣径怙徒彐忈廷忩徃怄怱弮忙彦忞怪忦徝彠彫怔怢形弩怫忠忡徲忉恢弸德忦恏怆応彵徑弝忤恕忘忌恨徰徿怯徾悒总徳恠彼怏怗徵彷弩恇応徊徚恇弃恈恁悮总怑怏怤怙恊復彷忐從彬復徟忝張彣恹忪恃忡悜惺愳忝恑惑怿後徃徢悴惢归徵忌忆忲影彧徿徖忒徧悂怷徆彝强怅徧弔彸彫徵悋忧徹悈怱悌怑徠徝忱忤徑忴怒廷恜恭徕快恌徬恮惒悂怸徟悵怱弾悚怪徟彿恆忤忴忠悚悑怂徢忭恰従後徳恝忷愀惎恻恺恦悘彟怲彵忯怗徎弔徎復必态徲悁惑忶徊徸悉徛恞恺待循怊彌恃怱怺忌弣徰忠忔徔彩悜徏忶彻怏徫恸強怞恻徊怤态恾怈恼必徐恠怸悐恻忕忴怏徝恖彼忥恱恔忬怭悆徦怜恬忦彲彧怕恑悼忼恸恰徙弩彋怯强弴怌怰徯弭弪循恲応徕恁征忘忿恸徧彭怳悞悗弻彥恪悄悋愊怹徊恒怚恓悡怯怺悡愫恚忦强恾怯徭恙惙恎恬徽彻怲忂從怀恓徴怛恨徧徊彏悾恿忾忱惁怴恴悊忘忬忊愞惁悏忛忿怃怼徤悩悕後怫忟徧彲怟恈徲恻悘忭徍恰恆怪彏忘弬恕徯忳彚忊彸悴怭怎悼悩忺悡思悠忡恢怊怠悲徑忂怟彷徻恉忴彞彨忻悤忱惌怼惚念悃彃忾恂悉怡応忨悮怼御怢徛恗怤徕徵忹惈怈恟悃必悈彥徉怒惛得怟忌弩恮徐怐忁悗怣愅怤悜恞恺悵恹恩悅恬徟您怦惊惽徺急忠恸徰恱忥恵怡怼惸愶怭悦悕悈悳徼復悞忴怪忑忊怲弻弔徨徣忒徔恆恁恂怈怛忘徟徻恬悈恅彉怗弆悎後怂彜恆従态悡志怢征怑忛悻徽忿恱恍悲惂惲愛怒恧彏忚忏得怣总徤悊忒征恛徚忕怘彴徍恒悐怶惒恪恇悦惝忉悀悪徠悭忀怮忑悵悴恿徤弛恓彝徂忛徇怶当忳怡恔怴恩忄惆忻忦恁徐廮弆徘御彑忸怋异廋待彎怙応徖彫徥忹忷恥忙弬徊忬怑悀怛恜忁悫徺徠忨忛悍怛悝志忼怜忎怒忖悈怵悈恢怾恠怙恛徽廸徴怌徣徏忳恞悌悴患忋彖徚彿彅忳恻徱怚开悽徦忔恄惯患悅忏恝忓弭悬徆惎徨彛弥悉怊怄怾彥応彐徺忍忭徳徿忢御徼忌惄悤忕悇恃忙恒怖彿恔忈悊彫廱惁徊张怓恪怗悹役廘径怲徤怖恝怅恐忯悇悝彵惂怩怉忥引怍悍忚弫悇怕忪徘徯徔恡弆徜彡従怇廯復恃怬忙彯恍徆彎弓徍彬律怐恝徏弸徬怒徒忿怵悢徏忯怶惬恑愭悴快怵忋怲応态彿怰徫徇恴怹彐彣悀怹恼心恂恇恞恆忄徊忔悧恍恝愓恃忛怎忘恁悼悔忒忹徺彉恊徢恙忊弇徵恭弸忪恒怸彘怼恵惹悑恗忆忧徺徢恻彭悞惙惜忯愔慅感悯怲徊忧彶恔彔恷弼彶忂忽忷怂恎悎当忊恇忺德徎恑悬怙恩彛徛悖徎忎怚忰弭急怋怉徕恮悐徢悂悒怩徇忘恇恓恢弍徆徊彚弉弦徿彆彯徫廫怙恐怬徯徉彩彥忻恙惚恽忟惝悔怙怍恩忢悐怿忠怚忺忭忑彂恢忏忥悒怳彮彩徉悀恑恴徽彭恇悌怔彬忴忿忱忁忷徜彴总悥彄徤悟怍弱怛恏悊彈急彦徥恶彈恂彩怼弖弭怑廜徐彊忍恾恆忷彰恸忞忥悋恠弿恐归恹怲徑後忰忻恼徠彪忄怢恟怢怒徬怴忝微徘惤彷恮彪悙忿怦廮怲怌彷彮忇怔彯怨徲彻很彞怷怴恭彯忲彏徥彲弫彟怨忇忲怏怊恦得怄徲彠忪惙彌悪悥忑怒忄惠恁忣徲悘悢恬忬忎忭恓弯惁心总悹微怫徒待彚彴怗恭彥廓怫徬徨怀怑忌恖恋怪復徨忡従彾廞忎忥很強徒怳怪怑怦弅徸徧徉怓徜怞恖怼忞徧忊恞忆忴徃後怙弳徟彻怸怢忊徸弯彧弋怪徎怱忋忌息怗怵弾彯恡忓引恱忌彮忣弴怜总恗恔怐悲忔怠惢怱恧忣忀彬忉恱循忒徻怖忊徬徥怪径忛恨徃悋悳悗悘彻恫徨悎志怎忮恠惞怗忱悰忘悧悾恡徛恷惂彪忞徴徙恦忄怦恬怽忡怖很彳恫怭惇悊徚思怖怫役恹恍忑彉怃悾忩忤忹悠恶悠怇怆念徑忿恿彺恈怓彵往录恐怲怦怮彌怾怘恩悶怔怩惗忆惒忙怡快忌怏怿忴弰恌惪恴慁悦息怶愡忠愿愱怭忆徢悑忠恰怫悖悟意恃徣怖忱悜忮恎忾忌忇怍怱怪徆悿彿恢弲悾怗恸徘彍惜徾怃廵悞怓忦惀心徝怣彃很張徭怤怎忼徇怸怓忏役恗恼悭怖徴忈恚忸恴恆忤忈徏彮恻忷恶忚悁忈徥弶怊徘徺彛惌怾惬恖悎恍徫徹怆惀恅忊徊忶悖恃悐徥您悒恛怙形很徤弡悝徖惎徊役怠惜忡彿徟忢恚忎從恩忡徍恜怭恵徥彐恞恽循惖怷徧悷恏恚彵徼忔恤恖徂徤德惁悹彿徃彙得恖恬思性怬怄悄急忢彿忇恍怺怜思忹怯恣徜怑彑待循态忽怭徢忸恣徵怂彋徥惷彚徦恝徨徒悖悢愈恞徒徴怜彲怑弞怀弑彪弢從弔忾彮恳恘徭忰怹强怼忼怑恣彻徘御怟怒彻弞彨徴径怔彆彃忱忕彀悈忶恘怅怡怿怄怵彺徳恳忝志悅彎恱徢怂怴怙彺忏徇怨恘悤悗忽怓悵怖悔惪恓怮徐忈忣彲恪恪彺径恟忌惎怇怴徱忦復徥忐彯心悑忱怾徑徤怦忞惇息怇恘怑徳怕怈恚怂悝悘彟從强彟忺弱忏恙徒徦忈恬徴徘忨怦怚怬御怨徬当彮徠徟徻徇忞怯彌怴忿忍悮忻怊怄忶恍待徦徻怆忆惷惱忦惞惛恊悯悔役彦忨弜御忹御恘御徒彵徒徐徦徨恇忣彊悐怬彮形彠怙怴彺彞怳弒恋忧彫弋怑徆悖急恱恁彺怴恇忽怶徤开徕怭恀忤影徘征弡怑従忐弳怼彌忣念忭忲恊応恍恙怢怏彽恄怲悾悑弾怓心恔悆怀忺彨悈恩恊怌恞怖'''

conv3_bias_shape = (16,)
conv3_bias = '''怏徖怤快您循怇恦忞恛忱応悳愜忚弐'''

bn3_weight_shape = (16,)
bn3_weight = '''枊栀栔杝栽柒栘梜柈杨柈柯根柂柮栎'''

bn3_bias_shape = (16,)
bn3_bias = '''怮忋徽彚恚忦忷悔徿徊怶恡徻徃忱忞'''

fc1_weight_shape = (64, 16)
fc1_weight = '''愿悧怓快慌慠怌庮彮忂廚懇悌慐建弳怵愍帘惯恄惕戹廭愞巪惩庺忇愸帣徙幌徔弴庸恩憗幱怍徹巯愶廱恮悤幾懌性慝懂弚廞怏帩慜忏廍怠弹憿惕徔年愪廐彼帕恳懕帥庿懘幄布庣康慖恶彽怬徕愕徹憽憌懊御恖巅惲幪怂憡役意恳怚弚弾憭憛廀恸巶慵巘弄愛惖恃幉忔彜廀憲恛恐慩彜忁庿徤彍扞弰悡悲彷惇怦彘截彩彍幡慺徉悸庩惻忱懓悙得座幪应恟巛愻幎彇恶悄怺恢怜徆弣帧慐徺慩愮巹恏忓弄懕弟従憻恁慿彬悻愤恞惩帾廤恑座愛憯徒廤戅廑怏怟慨彿愒従庁愍徂幕惃廻愨恱弦憍庡廀忳愛悱慩忪懟廧弯徜惐徐怔怵恄愑懸戻弗得忪态惼怇帯憭悷廸忖恦应愖戶庲懽庵応忿幪恟怺懄怎悗惱慱幈慨廂愃恛憡怸忎愦态怔憮惒徺徱忱廰懘戠恈帷廽惵憔徽彥彟忸恕愹廔恔悼帏愭恴惌慄徕廌愎憼工忸悹幜幙愥急戅忊悼慀幉店怚幟弬廨悄惰愎愂床愯幽懚悸幓恀徿恐弳庠应庢弆扢忯怉徴慁彡彩恙建弉懭廎康帎怨怖庢愢徵廰帩慈康忶戤彜怵彪往徰愮恎慿恦影幐徳幥帝慯床悼忣悞悝幱帢恗庣愨徎恉忢憡徤憣悴怰慡徸忡彩忋悽憞強忨愮弨弡忠帲幘弭徆平忧惺慲懩廂帐慶広恦悚憶弓憸惶慳扸庉戻建悕廄恝愧悴废彬慥恀廽幝帿戙彖悁幺悩惦廽廣巍惭徙懪幒忹徉幝弹慉彂忇慀恋愝影徉恋弁愰恚愸恦巊悞悈廷恀憛廽幰巨惊懟愳愌悱愲彔徏惡惂慉庛憒慂惎慢惆悤帊愆忤憟彾弍慇抈想廫彿总悤愒弑恠慠惜度廡愆廮愥庱懷恶愽懒忇愾慡忙徱庎彗廞慁廣弉彟彣恓悖憳懐怆庭戓廣慈悟帑愊廟悒庿愯憆惺廩憆幓幉憿彭徾忭懶惽怲庪彃弙恂怨愗态庪恢帡悻慃得憺庐彋廋愬幐愺悛戬懦怄廩廻憟惥徖惤彃忾廊帲庝憑庲憕彺嶬幼慫廽徶怅悮恈弾扁彁恺懺徍引徤慀庸巹弲庺徱徝往巂庥懈憣悼怱惗憞忝愗愚廳懮愻惧惤悅廎扢忇悛庪帎恭惝怢恷怅惑徱懝恗扂愼恜徝恭庍怠懐懜心弆悶弥弴恿懑庋憱憑怚弩廍愸惜总忁悔思憠帇廅幵悛愿愘慬弤怇慽惞序愫怺廤惔愫幟庞怹忐廲引憡悦恜惻幞恡嵴惝慎嶣弑幓彳慪廘愒帡怃悷惱愚懣広弨忁憱弩憢弻慗恑憀庛嶧弌懗悈巔愒幵愜战慅慭憊忯庝式惊帻忼已幟懋帩惹应廰憬徆巭帹弸庙怗戓廼弯恇戵帡帢恘懝懺徭徾戃愠彟憻忸忊思异幤戍廡愽懴庑廯慟恛弔廍廔忎廢彨慿怸憊幚弎惥恂徕愐怊悆扜恬徿惩徾憜怞幔感彭怷憶彭悴廠憬廵惛懩從幍恧慣彰憙憩恆徝怵帺恐憢悦憸庚恏庢憻庖庢弳慴廹戂弞忖廎慎怐憏廊弑悄戎帬憶恆怀帻憃徿惆忊巧弟幁愴弬彚往彞愾庑恷徎慤忸愛廎愝打慵師很慗憡恮带惑忷忄慹恦忻忸康戋惗愋嶑幝愐很憫愗廥恶恢彯愮恼戶扲慴弜恥截彉愛彞憣悧弮庚廕彥弻戝悥慘庿惴帵庒慼彞悯弥慅巸幎悒惾帞左愮惊慞愕愆悁慕忌愲帱帚惢帠張弽憑徔幎怖庈廃憍彏帅慕弬憧引懢弨弗彭忈惎廭慅弸悤悖徔弹怇徊怩憯循彇弩憺恃弲愂慡循怄悵'''

fc1_bias_shape = (64,)
fc1_bias = '''慄彅庠忟弹巩戭弹度憇弳律憾憺弙恛廐恦恓憅懗廦悦愹巰徳愬懵廂愫忘慤懗态彺恤怜恒慼帏彇戏慇慞愌惦彬慷憱後忨恓怲廱惮徆引惢慻弉愯帗帼彤'''

bn_fc1_weight_shape = (64,)
bn_fc1_weight = '''柝栩桒桄査柩柠枸栁栅栦柵柭柈枍栗枴栓柿栧栩栅柟枌柃柟栄枯枟柽柍柷柩桤枥柲栘栟柜柲栣栆枪栨柿栞柪染柇枽枆桳枚桡栩桇桗栠柪桗柋桤柎栜'''

bn_fc1_bias_shape = (64,)
bn_fc1_bias = '''徲恂悏忂怸忾性徰快思怐怶怎忉徜怜心怤忶恓怷忂徤徝忑忨恠忎怏忺忢恔怂恚徺忬怇怊恑怀怀忪徯恓忴怲快忙怅忯很悐怄恻恭怾恴怛忹悒忧恄徴忪'''

fc2_weight_shape = (128, 64)
fc2_weight = '''彯徹很惞怋悃從彙幑悒很徳恖怮忕怵悭恵徙廔徢庿悅忓惟惙怆急恠忊彧弨悸恔愛幨恄彽忟恻延弬庭忪怠总念弴怆念怵徒廞悛愅悸忸忩彣悠怳忁弆弔怭彧徺悋怕徙悙徢愑恴恣従徣愂彾忟忟彠怚忣徃弶德怤忆彆忷徻徼悪彍恣待彛悿徔必恼惸忯悭悻悄弙徵忲建悜恼征悇彾悆彈徠彯徇徉惇怍怗愤徭弉悐怭廁怴悡得愕恍怏归徐忦弗恺彁応恧延慜惘弌廉弊徢悀忥往弭弰復愚弈忡悈徘弆弭弛徑弖恭彏廦弱廗弣恙徟徕恮惬悝录彻弪悗帥悵意廓愘弓怵怹怔惚廰廟弇忺异悳怊情彰彥後忙惒弦悊弝悿怐怡恍廵弣志悾悿徟怒忌徒彐恂惄彽忳忥弜悏彻怫怩彚彟幻幟惿志悽弡惧忁忍怑忍惇強廥怄恑弤怇弅廭怹惎徆庶悷忯徶徕弈庥愮弼愊弖弳彭忾忨弱悍從怹廥忑恷悚恙怉怪恁悯彽恭徛惌悏彵忦惍忭惋忣怘愄忧徭恎彣悊忁惲廎悹弼幮弽忡徚忐弒徻彘悊悪怎惒怚幂廢慷忏惊悮忇建志彏悚恷惄惀愐廽怳恉患廖慅悈帞廝恣廱微当惃悄応忕彸惃怔徦忀弽廹怊悡廹廍徃忉怬惹庨悙忩徹悝影彴怒徫徟彈廏彟怡慅恹彘悸弦恏怋意恸惊惎怶恀弎徶怬彶彞忱後弢悜弒悏弥惗惕後彊廢彿悤愧律惃惥廈徥庯弱怬廕廔悐彼忠彝志悾廜徸彏恏怬徺怞徾悭弒恍弽忳怀恌慇恎弾悸愣徱恣徰恅愆忮弦惇忧弒徱惟忪建彠悖恶强悳心悎彬幸悎彳忪恆忷彰怑忘徥恒恰怳怯愱忪弧忭廼快悠弶悲廟徧惂忉悦恢惏惠怭彭徼廎怟恖恠息忼悜恂怬徕弇悡忩弎悁惏廉彛悦悄恎惎悬悌徾恚徢惚怬恅徕忿忈怆悦惢弹彚徼徟弼怪怾怰忮恑弦悞悛彨愜径悐恘庫惪忛弇彲庐弇悶怨悚形引御恾弆弊怼庞怽庠惉愘怹愫录忎惮恃憪恈悺怀惏忛恢息恦悵恈怚怖御怺形彎怓惏怦彳悿弮悑忹怋徠惝弩悢庻廧徹徴惥彭悧悒廉心彙悮惱忱彡徏忸惢愱庯怇彴悸患彝忭弖怴弰悒思恔怹悗廬弿彖怦徼恙彉忄弍恇恉恉弴怏忁悇忥志康忄弒悦弛怇忈弐廀总惆弯彧悲怷忘弟悧愋恦悿弥庝怰彈忁惈恃張志廌念弗悫忥惞惒怽录怾彚廾弣惋愛彏恑悻彇彎忔怞弿恹廰悒怺惡怚惃恴弬恣异怕忖従彛悕愬忨忢恍态忳徇悝弇惰弸惫徲徢徇志惢悩怕忢弐彶怸彸怋忁彜廿怢廥愤恲庽愰弌忣恊彿彎徙弧徲惂徼彆恙恛惒恓惨惍惍忼惓弬很惎怷彔徊念弄彀悘弉怦徼彨归惦彞弞廽惗悰形愭張得悁弶怹恕弇恼徳悽彸従待徆惎怋悉弜弽徍恘廉弪彰徼徕彌悔怯怘怀弦弦弸恌悓息怮恪忣怋忱彀悢徒彴忮惹恨惈悁忒恧廴徚廝忾廈怂悒忺恰恹恳廖忭悷弳怘录徙彝弻悗慫恘弁怠彐恌惖很弄廲怍惏徆恔悕忘彑怏庽忟忬弮忇忎恄恱怿忔悔従怟怒忱忥廫恨弗忂恃很弭愽恏惭忋彸怵忴愎彉悪弽怹從徏恨恎得彍慷怼彎愈悑悞徭廯恟惕廃愒恝徥恣怫循悤循庡弨惱很悥径恊廎悃悿忙恂悉恵彰悽徕悑弼徨息恸彆微恶忳恱恡愞怬念怫忎惋愔怾恋徉徂惾惞愀恒怞怙惥恁悈弭忞恓弍徿惈彂徆恾悵庽弭弛怍悐恭惋徙怜惊建弣愎快惉愴惉忦彈從惃弎彛忖彉徨性悼忆归徾惲悌怔徬弟悵弇悔徟忇弜惘彪弅廭弴忑张庽彔恕廂弨心恵忈悸恥惫忆弜御悔恹惋归彫怐怴徭彖弐庆廴必怼彐庿忍微怎弝怭怋弬愺惒彚愛徝愠忬彦忧德息徿感恤开忥徠忸愱怄徶怹恓忁彨怠悏弾彋弶忇徱悘廲恏庡恔恵廵彽您悮悤录恷恺忮恄廴忼恐徟庤庴徃弥律彃徺徙恣息异微悺弿弗忍忡忹徶徯式愖愙廵廙忪忕廈弹彌恾忶恌忴弔弿彋悚徟恈悄悥廛心弪忝恏恆开彰恵徤徊怄悦悙惑忈怾忝徶愒徠忞惉径彨愉惆廢彦彸忑忿廨徏廻悶彻徙怀忕悅当廋彠怾廔怪心悑庯惓怄怆忌徂悉忱惞惔惻弴怭怖当愄忀恤彁庳得很恸徙怰怲惹悎怐彎征彙庝庩徰廣悆怿忺忘庛彜弞恓忑总怣廿恐徥恪彠彈录恝怣徳悛当彷彡徐悈忣径快徸悍悙恢怀弯忈愂徜态引恷悶快悙悚庝怡廠怛愷徉忄悰弄徏徳思応快忬徴弟忘恡弫恉恿影怔悐彨恻彝悾愜徙弢忦怂悕愖廸恸彰廄忊廹恃悎弯径惟怰忢怶徃庱徵徑徊惨廠惶念恍惽廾彌惸彧徝忛恚恧恅愬悴怩怷怖恚廼悦循従忢弧悞庭彽很弬忺恫急惒彮忭惎忑彲怤怂弁张悧弸廦怖忲彜形忲恔忒彂彬悅弒忉恃後恕恛惇当怋弟彔惿弙怰廢庸惂庣恌恨忖彥惰悎忯彿快弛幵庇悘弮总思弴忹恳弖恱廜彉恎惀怷忾恸復徇弒忌弁忀弋彮惪恙惏恠忷彁惀廞录彡忙怀彡惪悯恞心弶彯悪悉恦怃忧悬悑恝恵庿弸恗愫必恓忮廇惐庳徴弗循恒忩彄影惜忭忡悧忤徑彳弫怤忽志彽忘弿忪復志录恜廁廀悝彔悴恔悻怋愡從怮從弅忈廝悸廮恲惫恹忋慖廜您德悉徾徥廍恇怩悪律徼怜恫徊彐忂彠弿得憬惙恵彂廼悝徑徑悆弯悧悥廀忮彿忲徆恊忢愡悇怛怽情怹情愱弔忔徆怽徃忡惵忝惴悶忮怳徻廙恗恙廇慓彳恲怽彰忢悵弒怣恷怾愔怸怯忟恻忒忉廈廓弫忞徕怗彚悈弸怀弪惏怟弡悾悵恂恸彶復廌御徔忴徼惒恡彄廫忱弧怂忄愽恼徎怠惖彽彴忄忐开怭惇忀忭忕庹怇怅悶彲忖悷心怑庳弅弋忌彦恺悶彉彫悕徫彭彜惧彦徺惄惄忍恜弾惏悸悽怾忚怽张恴弼惦徶悡怌悞忆弾怵弌悦徲彖徔彨徜怜怪廨徬忹廢慪彃悌廳恘忔恛悚忣彝徉悝弮徬律彖怇弬恁惬怇恒彄悏忳恨惣感惤恟悊得悡復惧恾恃恷弋怃惹怚愍怫彏恫恆忇彎弻悤悍惝悺弒悙廂愶延悙弇建忛当恄彊徾恔心徣忙幹愬怛悓恽悻恵惴恉惟弶延悌廫徦惨廟怈徴怖律建座弸彠惲彰忪徇忇往当恊悗忥悑悬彭悷恠愺悅忯忽志彁愌彰忢恽弝愽弫悆心惁惇徱惶徰悠怯後念廽惆彂征帡快忞当态恈庪怋惈悹弤廜悊悙怯徰恭弯忳怀悸彖彑很怜徚往彥徠悛悚恾徔情弟弔彎忻怊弽怽怣急建忄弜憂徏悰恪弽忔心怐忺彌廅彶徚怨弪恥恁怱怴彌悤彑彡弘彯怱廦徹惡徆怈悗总恲当悅従恖恕彦忟惥徎忛弲彞廥徢悵忴庹忮怉忤快德怆徟廍忟愎忥怛惀恍彴彘彖怅弊徒悳弚廎恞弉惓彐廴徯恇徳惒忠悽恜恖彨悶忔弾恂忙您悈惤强弞忩悡彘怫彟愘徙怿徽怪忔悲怡怗廖惭惴悓彮愅怀怞悳惑恗廰徺性恚恨恆忤弋彌忄怉愲怑恅彤惖忺悺彤念悜悮年恦庉恸彣惾悓忳悪惏慥弯怌忭弣惗慑必徃態悟廃怭惇恢怨弚惝悴恍微惠恳怤忟彉徏弙怙忤悼彮恫怏怪廑彾弮待忙忩怜庼忠惑惆忊巤怇弫弳恲悱徸恍恡徦悒悥怇弹惐廤彜恤愕怰廱廙忾忷弚悜忾恍徫彜引弍廫庖恒忓怛惁後廒悼徃态徸忒廻庵悭怵忧弃彿怜徃恏徬忰惃怙彗徰怚庺徕恕怀徦弾徭惍彳廧恡很徐廅忙惔往怼廕弶忱怢弼患悀廒惎惢彻弓悁弁彂彻惵悋悭弚惼悴御恄恶忦悋怱恌弼恃弋悯廈忆忸彯恎怟忆彄惌悃弯徳恹恕恵廯怸怫惎悄忥彎悬庡弛彾慜弞愨彧彣悇悡徏怜怉忽廛悕恭愀弃徑强怗悃弄弨悘情怮恠弔彥悂悰悽弁徃徭帴弪恦彨彠悢弛悁彤忋弐怏悑彌徽忄席恋怼廼忚惑彜悾悘廏廒恡徂必弸形惽彨弩弤徦恺恒悾惌弹恈徨态悬忿弑彐彀忀惇彯彺志悱恆彴悶怳悛彛忄悝彲慴惕悸康徝惵怠恈彶弻忝愿忲慣悔悉忮弑怗往彫強急恨恧彮彁恀怖忁惕徵御弪彊徕弫慉悜悂总彸悧恇徽徢恋弘悩怭恥征弒彔德惀恂彫忽恰悿怼惥座彡怯怼庯愕忰恸愕怺後愨弪怱悪廄忎忹惞弻彗彝怍惫恂彦忨徦彔快弟惁怓悰廌怉徕强循徘恨惇弊建悻怣廕忱急彮态恱彨怡恁怢廻彟廞恠忸弴徠徰异復廳庩弨怵征废徃惋悘彘怳惌恉弅彿张惙忢徹彶恈悅悰弎彌悑忎彂彔彤忔廊弘惩忯忄庹徫怚悑惃彮庑彾彰弘怙庥恷悖弎弽弜弢忶悥忡循怱廥忇彰忊庽惙怚忶忷惁忆従徯弃徏廲建恌忠恬悓庩悁御忝惶弌怫弦恅愃忭恓怊彃恄惰怘怂御惉建惐忉徝怰恦悟恉愖恶惯悧弥弖彤役引彺廿忍従徫弐悺怏恬恭弅悴彭廸廿恿弎悞弑彚忯忨怊怹惖忂怦忕彻御性弋徺彥徱弤徍悵怏彘彨怲悆怐徸忣庺怄息彌忹忿悥循恜必忙怍廐想幻弧悏愋廻惄幙彷徛恶弭忠廼怩怢总徜怴徜廧彜弟徶悀息恩廌庺幧愺悌志徻庌怗恤愸忯悙広徴恏怬忈庭忓徺怽思恄彀復忌彣当彏恄怆彵廐忆弁忼徤愍悮弥弔怖徯廠徑忁彣徬悼恧悬式悡悥惰忭忓惝怀弶廷忕徰忿弜悽弘径弱彍得彡徎忝恅徕徊悥恱悳怆忞忘恠弑惍慷悁悵徎惦怬怎徔恻惉忖愾忑徢徬怄恌悗怂悇怳弊愁怐徽弸怙恸恵惺悤悁徊怷徶彙廹悃態循忔悫彙庾廴徊形悂恗恷廸徣悜恝意怯忒怶惠惋悵彅怛快慎徇彸忶廆從惲归忹惶忈恑恕徹惇怑恖愗廨怎恧怶彎弌弐悄徱惶恜徣悝恤彶彸愐廢怡忟恏悈怪弈恃廵循恬彊张愷恫愅悬彅惙弙恸忩忴徣恚徳悛愆恉庹恹悽悞径廼悌感怱彩忩悻怒彗彋彎度徣恼役庾彶徦徃廾悖悞愁彬悗怬忚悬悊怠弣彧意怊恻弗怽張彴弪弳彜态忉引徥徍悍怽弿彄後弢恪平怸忈恳忽悦徉徲愻惗怹悚彘彃怣悎徲怜慮忼巳悠忮帠惿廌廻忤怮怆怸彭廸幔忱怢恕廉怮庤怔悀彤慁強彆怇悁引弘弳惊徟徶怡幔怩怋待悄怸惗恀忾彾愊従彊徰怿愕快恴恛徢廠忪忠愪忟弅徍悾悱彰弉怆廟廮怴开得忳怮恘後廧恔怬彈悎德徖廯弸恉惔彏忉後悬忢彠弖廒彏怡忼开忮廨怼悼彴彵悰徦弑忓悪怒弭志惛弧悉悯思忈忝廃忘恳悸恥庄怐怫恺悗彗廩弻怮彭悰恈怐役愜彺悋弻怳恟恆忇憅悀弚忻庒徱怄徾彽总彜悲徹忔志弚愊徉彎惒悐忏忉恦忟弖悴廤忊廝恀廐悍弤惆恏弆庬庴徊恣忞庰怸怤彌弈必徎慅徕悠怰徯庚弜徸忴惁愰彳悍悯廵彫恠彗廒幪徆恮恵想愢怜惛後後愢弯强悀怤怤愄愪弲徉庾廖彴御怣怪彷忍强彜忈张徭悴彠弓怙弥徊廮开廔怸弣怀弰廆弐徇恡惢悋微思廪恸怪悥彻恷惗怨廭惺徥彪廞彝徕彊悓弋怮惚彘忧悰彑弞弱惞愇待惱引彾徭惰怑彍廭徣忯忶彞廩悚弫忕悎惹廤怀彈惕恥忾悬恡恫微彃惐怹惍您惇惯忚弑彧急悆弈忊思怲徎惩弲恹彯怎怹恚彃悤恶廁惓患引惏惟徴彔忊彄忒恷怋悎惌徸恉悵悜怇廣徲恞怷徽忊志廌悜徝恇廯往惬徛従惫怲弧恽怣惪弛怯忐彵悭愊愣弘廜怈惇忮怣徜徬徱慡彷恆弗悍彋怘彫悛心徂恣廑庣彄忴彥恝徒徨徏张彫恃徐忠弧怛徧廩彬彵廋悍忇忹徏弾归怵建彧开彑得廼归忀愽惲徉悷康弞怗廫応恙恛怤怌强恏彚怼惏彆弔彚弑忻徫惣悠庙忊怰惉徥悘引悛怓怰彠忷怮惊忻恒忼忈忥徤弻惼忓愫弳惷快徘徢悖形恀恖恌廽悢忒弘怎恼恥弳忾悔恼徢弉悦悓思彺愴庯恔恙悙徵悍徔怊廡徬惴弤徧忑悌恅惔怅彧悾忯徊彑怢忁弡強恍悊恨悝愥庲徟庇忊從彸徖恴惒彍忤怪怞恡心恋悡廱忾德愂忎悌忁慫惣慌恫徏弘怸悏恹怵恙忘徦恏惗徭惆恖怘怐恻彭悎怢恳廓徳恋彄惇怹心悲彠徨恝惘幢怀彿徨愤徊徏悳弽弐弭彗建愑彤庹忑悊徆恢忾恈庍怢怑帽徾弒怔徬廟归彘徆強廰怱徃弒忸廦弔徏徻忏庺恿徬悦悋您廿悓彛您弹患恭怀异恁悭径愚徬恮惽愪忂恦徴悇愱悤庳怀徻悜怦待惖恍怠悢必怍恩悪彇怙忔彎徶徙恏怯彸悌惾恑徔廔惇恞廃怛悉惋懭心恱徯怒廻悶忓忆悷恠彋怦彯悵怹廋彮弪忉忹廼怢忬很当彨悰惫巵怄弧庇忙慨悓怄弿弔息廝彞帶忶弳彠怾廞当恙悼彇弩惶恡庄廴徙忪廽徙忭康廉弬彖彪庤愺恒悈得怏怤惆徱悤恷恊役弖很怊廸悴悵惼忑悫恚忈想悘怙弯怐怯恮庇強忙徬彚恊彋弛怣弟惁役怑徵徳恥廱恟弆必彖惜惆愃悎怕悹徚庲弇怕忉徵愷廠并您弲弓彇弆悑怪徹恠恈忙惞弌悙徲悯徰弴恟惀弶怘怍弌庂彥徲弦怃庸恗惴廕悿惠愑怎怼录恱怄待徺怐彨彯彷忽恖忭彦怫忟怑徊弦悽廭愂弱惣惌彍徍忩徵悏惨廎悬恦廡忕惭悶廩惬律徫彦忤惔恊悂愃恲惇恙悢恼彬恓惹恇怃忀恰彬悒惝愀恔彖恓怞归彅恫怚忰徘弻悖悊忟惱录惁恔惫恇怸很忲弗廅恴徠弾忾忲怃庵怏徨恛庤怡忀忒彑悿怤忐徒彧廄彐彃彳弜愕彽弎廨怽惁惝惢忖徣彸徕悧悓徑悕廢御悮惐弓快怢怽怩廉愛恢弟恐廨悌弾恛恲悖彘弽恾恁惡徫悒恶恉悟怺怯忚廢恽彽恍忩廡恼徭您循怭恈惤悺悭彺恸憅彑怵恻惤彈弄德徐忢怞恁忣弗怷彁悺忧忽恘忾怨徔愘怨忤恣思惫恬廂底庵恬愍怀怤廰惛恡怚待徲悪府恹往弄忖彂悪悸忕彯彇徘慍忭悏怯徸悁怱慂怑忦怯彪役忓惷怫忈彠彍恵弌弎彎恒弣徝愃悇忘愬愋忑幃录惇彟惯彞恣惸廃忋待惠想忽患徫常弋廹幠怟惜廿恨惚廿恮怯忯恰惒徨怆惝弫弪徃弦廙幨彥怡徜徲恏往恾彧応徬怒徕恽恈恵庲徐性庸彛悘悋念怎弝彳忧徘廭忋広恍悳待弯愍惬悾忘怽悪忋愳廝忈彌怓彗忍愄怫廂悈弉徐弉悃廒弡彰怯廱式异彪律忞恻怗悧弗悡徜惊彫彆彬忠忙悓徙恟徐彚悘廷恋愆恨愒悓從幼忹徚忌恞徒愧幓徕怋怭悢彀悻徊廽形式彘弳忠怇庪彌忨忻惑悈弣弯彻彍恞忭怒怅情徂弯怺廟怇忺徎忸惃悘愡彣彘恾徑忂徊惉怨悸悩徐弹徴悕忮怾彜怀廥忑徻彮彽忍庙怪忞很彵惨恲恘恠恄幼庌彪惛弅忝徟微息忒惚忚弘怈忛悢恂庠建弙廠开恸彐彪忣恭恽復恊怖帻強弒恷忋彋忂恱悬弗忁恋怮悖忥忄怟幚弥忺怱惢悮形彸悑彽怣心惤徳彭彎悬忨彂忁悪庝悹常悿怛怓廣廉幩悦徳忉弹悖悌悝异徨悳廠廘怪廥忱廨廔恦悪怺惐恡惲忣廇徆广念悉恳徔徊怊惊廢怗怜忽惬庮彘徂弢悿徻弯廭弴怬庸廞廼強応怿廘彏废弞归忏廱快從弼恌座幹忒廊心弬征忢弓怬张忈恃惱恖廹忪徺怵廑弬悝恝忴忲庾悍悍惓弝彽心廞忭徥待彴惪弤怐愠慓忼征患怨怒悫怿恅忆惄悈幼彶恩徽悩怰恄廣悊悊忦惙弔彋廧弐恐忣忢弞征忠忦怩恙恰往廰彆恣悡徟徜怘弾悦彤悰忒恮恸忸彨恫従怄徂恬廚怖彅情忦恒怈恔廧彗忦恮彔忍悇忰徿弮恾徇彿弌恚惈悳恧悿廾怳忾恰情怫徐愰当怙怴忆悟徛忌怢恑怠従廴悗悴徠恮征愼恚悲惀惎怸悳怈徻彴彾愿恵忾弃悧惎庂忡归庑恧悛恬怉愀忡惙徵悓怼惎慂恅徰恇怄彍怦怛後怵彿徲徽恝悓悖弦悝恼恫弟庽惞惗悸康愋微忮彃怗徥恸怮彯憄悀彅怌惚彲廭彪怃弇悥惵怀彂悟怜彡彔恲弶彴恂弛廞惁恕愵憕庯愪恪忣悢庎惄徖彯忤怩弲恓愬徰悫弞愇惐悶惷式惞愭忐忌悯彶廀彉廽愁愵忕徜彿廾悛悅忘恋彄弆悗張悳彘怴弉弾廁彿彋惎彏廓忢弴恹弚弬恭惜征恣怅怾悓忕恗徜廮悸徳必悯徘怱悙愪微弮惧悠恆必怠彂彺忄恭忋惺彷徘心悠忡弓悔恔愞忩恅忷復忂怗愇惘廅悍径录徇忀弜恐恄很很忻忮惂愤慂悹彷徳惁弜怟愺廪惶怮怆归惆廅弽徫得恎惹徵悸徃徒恘庛悩忟忇往忊幜念悝怆慄怾庶悛忴忠徼忼忾恓恐惛徍惰徊怺彴恹怯忈弖彺弜悌廲怛恗弑怤惌患悑张惒庸忱庖恦彫忘弯彈悏恟徃悢惈廼忪怋徙怹总廚忻惑怺忯恮得庭恶恜彀徯悁恒彪彖廍惢徧恅恥廑弼愦惤幋彐怖恗徝怀忙惞愳忦恙悵惸悋怅忝弇徠忰心恹惦弌徲恵怃愼徃恦忙惕愔意愃忪愉忽愜怎廑後忆忆慲恞庼怕彋彲忈廩悥怚恼悮恩応怅弅廧弾恍恴彦徕思忬徢悥悱弄怈愔忐怏忰怭怅思悋弩彎情恨幰惛彘彪怦式弝悛怙惎廋恷弟徖廬悅忶廳忮愠徰怋忪恰怗徳忀愡恚徯徭恑徤悇恁忸從慈惈怮彪徧恀徟徣徇慔彯彞徿怒庎廃惁弇彵怳徳忒彛怘您忪怣愧弌徂惊弦惔悶弲彍惵徰徣忓忟惇怈思忤忉恜幵惘悻怈弒彁恅徆彼徚恲悒彃徦彣惖弫弚怵怹廬弙忉悶従弯彣庇徾悑弦恵怭忕忪廳彞弸恇庛惻弿总弤忔弗怚惮怹微彨悑忍廪惓徯幷忖悫惝彨彴悸愼廭庯彟彜弴廌徇弞廨忟忁惑很徹徣忦惈廕弉徆徰忿忁怦怴弬庰惞弓彠悄应彴恃忏怤弉悴恴彍忲徚応急悴忰愝徨怷弪弜悡廈忽徐廟忾彐徘惈恚徴恚彯恑恻忩怇弩恼徰弤恑忠忙得形恍庢惨徏徉弅惙庵恵恢恭悐従徇怃恨忇彺悈忟怀廤彺徢彯徝惘忍怔恽愫征忙弉徒廝徦怆廮总怅庒怛恩您忊恖幗忚巡恨徣慟愬恭忮徒悥徧恔彩怭愒怿徣惞恃帖怤悹康惊彴彙廡庱怀悡徸征徘怵悉徸恔律庱当恰恋怤庽悴悴悻循微徜惞徏忊恓悳忰廫怦态弝忬弨弎彬彦恤惜怕弯忝恖彤忓恾怟忏彉廷彄悸弾悷徴怦恆幍悓愜彪徨悡徇彄忈怭心惥忊悴悬惝彃弫廼张惺怰恧庡怃弟恜復恕忏怜忨彶悶悴廟弍廕弤廞惖悐庪怕廲忇庄弣彙徨廰悾忣怅悎従徟惇彮忐悪悘怷愐怖怍惌怲悞彬怌恞惑忭待廽彧徟彗忇彈悐悢惷忺怵悮张從引恝徽悜弌悇廵怘恾怏恞弁愐廁忎廢愧忈悫想弡快弍弨恦恡悰恷恵怷徻思弮怭恪廹座弦恿廹廬忟悬弅急彗忰彤恋弱徯彽廱彬念怼德彮恩怄彈弔惖忒惥待愶悉弘怴惎役弪弅弿彻忷怡徳徻徲忾愔怨悿恭彡形弭恉怛悴怿怺惍愐彯徃惲怑忘心弃忣悎怠復怍彾弃悊悹徛徭彟惐恼徖弽彍弁恕恥恀忈徬愦徣愃彡征彬忶悦慈悞恃总悱悡恐徵悗很徿彾悲愚意彩徕弖征徿怙廸彗患悅怮忪徉徝悤怱庻忩怜惄心徸彩廪怊惺径徺徍愙徛惙廉彟庳恫怇徆念恼忠愂庽怠彚廷弆惭忈徘必忆庅弟恷愰廹廵怕徼彺徨廓愿怤忊怳录忸悰忦恆廤徻恤悓庙幗廿怦恜忆悭庤怬怓忎惓惇悹径廮悏徒忊從必彵弡怤徽愹徢弘怨征忤恒悵忳恀彁彗悟忑庞悳性徘彅惄彂廍彇悧怀徃悌庡怠強恬徰廏彼怵惦徰恅怵彐弌弤怊彷志弣徃徑弤忌恞彣弹庞征彋怐怳從廖庛廳愂彴念彏彝快恜恮徝帑弲忲徸怆怂忹悳従恿愻愈彜忷徛忏庢废弮惌很忉恢恿忩悴幵彠庍愧彗彆恥弸怗彦总廨恵录御廐忙庭彧恺弞庀愕悓彑慝怈忖庵忴御忳怚悁弻悪忆惞悂徸弳恙弬悦忿悩徹惻惸惠怩悹怼彻幈庅怒怗惥恽彫悱廑幠弄愡悖従惈彾弅忻悇德徟彇惏怦庢恻怡悪徱怡怭怅彙彗徊弣彈悱惄愁惱府很怲怇弸怶息怅悙悍彫悦惠彶志廥忔悧彶忲庸忦忏恋悹忘徵彩怙弎廤庍怾弰弁忧律意廴悆忘恱恕徂徟忧徫弐忇徒彐愉怰廷性慫徹怏徵弇廼怒废彩徣徥强怕忭徲悆彁恋彵恮幌悩恫悉征循恥彿忠悟忨循弎息微愥役怂怟徍怫怲怀彥悟徬怋恴惰怀悢彪廵怪忔愋復忒怯廷彝忚庞彩忮徖廵怆廃庎序愿惕怣悆惻愞怄弫徆庳恄忯怣彏慩幉恢彎恬彩悚惃怠恜徰怏形惄怺悠恙怰忑徠弉忸恡徑彰悇悔怿徟帠恛您强惣愮弞恧弅忶彛恪庝彌恲徙往惀徢徸怞惚式志忕弦悏怽徏忦忪悆怏庼情怚張廽彻彑徂思忂延恻忏怆悲悎徚悁忤徒庞忒愽悐忑忲怡怠徳怔急彣庑怟忁悔恹復忻復情恄悓從忷惆忙悞徨怅廝弇惹怌恅惘廩惈恔弘怜弯惤忥忯悔彑徉彖彉徕怊惎彅彳惖怃廻徵廸徿彺惈惷恖廰式忶忁彾很悽廲恈怼彬徺恅怟惺怲庱悚心慈惢彁徧惒弨怿恱彖德恃怗廀廧恩彪愲恪恙悿廹怛廨悱忉悊悍徃庲悟幁庅幰征悠恶廮怍愦恆恙悱忇循庀悴忐忧彸庼応弢悥態悉怅恺怳忿怪律忘恽惉恘怕応惨恻循悿怷怼恽彗恑忲彛恆悰廆弤怦怱弞惬弃庾忊德忖弨惎彌庞廇怐弅悂怭弇悱惸忡徒忢强徎從悒惙惖彯形怐恮怯彡愉怚悥忝愿恥惐恋徫徲循怦廎心忤惃往悁恛悎悳忶恼慏廢恫恱庒悪弼恆恁徖恕愘惶彯怛恺愚忐怋彠忆急恁彝忀悋恉徯恩弅怦徇恻忑彷惕弫徾忐怦怕忴惦愑徨怡彾廦廟悩惃怿怙惦怨悠徙异庪徱怺徃徳愆悹徱弫弑恺悇惯彾悏悡忲忚徆彅恚忌弛恇弛彀怙徐惦恧徚廪式忦恅彝弓怖悉彃弿恫悍彄悵愇張恩恇忢愊怏恬徠幞忭彁徇彄怵忯怚彠恄怌彩恆弞徛恁怬快彇忧恱忞悓恇恐徴悜忚彥恭弼廟恅彗徃徺忴徫悴彣悮怩怠弭弶彐弩怲悃悗徛彺快必忔忹庒悠怨彆徭恮徰惭惻弢怭忖忑怋怾悷恥怾弖恈弉惔恧悪彨庶悀徤庣悆待彚恻悓恦弛怑忼徟彬惛彗彿弆悆廿忿応御忛悴怅廄後庉怂徦惹忬弤復忧彔愄廮徢恨彥恗恔彞恙弉弝彞弇廵廊怸恶悙忝彊弔惢廅愠弰悊怑忳忢悝恕彽徫忮恘恪惕怊恑徽廱忬忪怾彟彺忱忛忕彛忾惫悀彡弽恕恹息徖恐彿徤忽悂廘彐悘恥怪徼御庲悏彴恌彯恭徥恝彌徨怸忊惁愫恥廚怷怎悼态忲愚忄怆录怴怪彸彾徯忈恪徶愊彣弗惠悓悧彭彞愣悳庚徉悠徕怳徜彀彅徉怸弐徣径憁惆庽徚忨怵快忒惆弍弝慆廬惞徒惉悤彻惒悡怼弸悪恜忬彥忨征彑悶惁彜愈廭慉悮形徻弎忼忞怕忶急急彂弧忧怠恚惚惘怢怏弚張彅恹悀愄忢悃愅廩忸惬惘惔忇怓弳怢廗恌态恮彣恮徉悟恶惫念彷待弥愷悠愖徼彾弟廛惜恢徫忆怗悕忎彸廤徭快慽彦式往彬惯怗怄惇建廳恃弑恀惬弞悼忏弉廋怄怠忺廏念恽惂忉惌悾悋悟急彜弅惝怗彶忪忲悷彫惉廙彍廽憗恱悠徧愍廥徠彾愆徣忺怨悄悢悄彧彔愡怯悊徛恢忷总怱彤忯彰忧忱惺庋庞怘忻弸怇彫恴御彫恪恿彔慪快慗恷廕惑恕復惏忠弲弌恀怔悙悔悼弟怌庌彵忪恆忑廘患彺従恫德彟怘徒恦幸弑後忊弹怈想徬彫悠惨怨惯忲恔恔怴怷性忙忮忣悥彮忱徽德徴幒徣惎怤怒惈怷惭弡急怺徘慕怬弲悹彜怚悺彍悓愼愈弡彪彑彊廨廋廈悘彪怾悖悼恄幍币悍恎庭恻恹徶患徱恆恤弢弩怣幫彰庯恩從惉怡恅悢弸悤废廈悴态怹恾影忴廞忬愸彴惿已悃悈忻恜恞怚忋惏怖忳忤弈恻恀惉慘彜怳庵徟怀忁恑從怳廳怗彂悇恝廊彚彰彦德徾忸忶忦彙廰徣广弖廸怦庽恮怷弙怤惈徂忣徰徲弦徒忙弮廩悡悇恙弅悘弻彣怩恸弚弑廛忦怓恵怩庫恝惧怑徍忒幰悁弟惠恗悢廨彂度廄悄念怿彼彑恭後弤惑悥彿愕感彳愁忑惫弇悀快恚彔恷廵庹怔悑忀愋惧悸恨怾怒彅惆從影庰忪惍徿怛忠悓忾徲惎彦怷徫彬志态恲怏快恆徊彳悬彀弧怖惚庮徦悇彲感忉忙徫恨忬彘惏很慁廪恏弾往廙忬彀恩彮惽彳愫忏徵弬彮恞忼廇愮徛弄愎彙徐廼彝愄弰徟恏徦張忦廀恿彄彨怬愊徳恆强德庾愕惬床惘彄惂性恓弔弑恴怚恹忢恟悼惵愄弎弸怜忦忮弰忛态徏得復廒庱惋当忊彚弁弚恮廰彥恕廖忳愚弈愵忠惎悼惛廇怗待怘忏忇彸悴復庪悋幦忔彪彭徠恂建徐廫廆怡怕庌忐庾征幗式彸强恆彷忿廻悊怍彲惰怟徚态恍徭恪忠幩廗愇怳意悑彠感恜怴悛廀徚廢徺徾彇忂恆异急惙忮息徍怜悭彥徏悅弿惲忏從惉忪悯悳徴彡弈怕怵惑弅彞悠悪弞庐彏徶廨忨惻廢彞彪惃慗惣徭彛怬恦惐彩徨恽怼徫怞悥怦弱康悒忈彴忎從廣徹恤怐恧怴廜廽恢惒忱怯御怹徺廫怠忟徜弾悒彲忔忨悀悔弈忌悆悯彳弔徻忕恕悔悊往怩怳徍惠怠張徢怮忇徙徺弻忯惐彺弳惠忇廏惎彦忬彔惴弾忪悒恂弰徽恰悔悓弭彄悆徑弙彮忩悫怚影彩徍恀彞強怩悼恂忚彂彍惣徿恖惈怼廼惐径惟彰忴忎悽徑弩恭恡彯恦悌怇惃彋徶徤廢悿忂弦廲弡悤悚彇忛悡惦彂彲廭恅怗徕忠庑徫徎怯恡徐悉悀忬彊徰息忸恝恈引忬廖弤恧恗忹役怽心強悝彛忝廽怷庐惏怨归怺忴彵彘彘悯忎弄忄恤彆彁悁彋弨忒徏归悦彋录怆恛愕悃弲徨忝悋廩廁怶忏怤恧怈徳彎彎彜怷彰愇怔徂御微廊惚很怺廪忆忪忭彼悹情怰悐怪弱态恽慓廹引徼徬忬悬恧弍弧徏徝彈徚恌悉愮廷彊弋悠忯悖怔応志愁悲怐彞廫惘恋循慚怢忭徟恶弟弹忁廚怒悊忈恜恞彞悻憣怅恷忤弹忨引征恨彜幋彞忺怦悁彸怖恥忒忓弚徊彾怌徑弧慫忆忨廥愐弑慀廴悳张恹廢彴忝征恂彿忍弔忽恑怆弑弯怬怂惷廞恞応恑悁徃恼悊往惥悁徜恌惑怖悒您恵彴怾忬悆後患悳怳徛彠弰彉弞悈悼怜恿悋彖怫彰恆悡廯怗悵徠彦往惺恧悟怈惌弙彃恿徙彾忰恭弯恔忚录惻患忮恝悥悄忱悩患当快忷廪徏怃徵惸悫忒徥忙彏徐弰愍恑復彜快徖忐彉异干恆忎徃怚恷往忚徕怏廪彍惙彗愴忖悆忪廞恺彴恬怟恚愨帮恒廙恓恰怟庌彌弩彯廞忏患弄悏廒恛徶弃心忯庍徤惭彚弋廫忉幜庴彑怠幔忳怑恉徒恐恾從弱徝恞悂悯悸恞忾忷徠怊忍幽廾愠惕徙悕忷情怂恬悄怓微怌庞彈弫恗惄怐弟徔忋忠廴怊忒怴忸忋惴恐廡忼开怴忸恫惗廇幪恈忰徤弾恮恻志忇弨彷弢悓廏恪従弯忛怠悝律恴悈張彻恱彈悄弋惝忨彻怾往忆慆徎怦恙忈悘彜恂忭怚忐恧彲弚徐惿怵弨怤悱怜彀怂强心悵悆彳愁悠彵弥彦怸忦悃忕怦恱愋弯彬悀徔態悡悩'''

fc2_bias_shape = (128,)
fc2_bias = '''怅惞幯廪怹怬巽彛忑惻庛彤恲忢忝惪忕幗彠彙廘彶弍庄希廱怤怈徼弞彸徚徆巌弆怋徛廑怠彩忳悓幙幸忔忦弳徭恒庤廾庍恩惇幧庁徲庘惺弥悁忔恦彇弡忨廀応廪幾廽怳怛彨怋彝廭廽彬悙性廞徦弳彉幖忄恫廢怍廷忖嶶彮徱忂幩彏怀忝惗忳忔忱忢怷幫怟廑徶帑念巡幤弒怬廡廨廟弄悮心弌忂弎巙弈彞'''

bn_fc2_weight_shape = (128,)
bn_fc2_weight = '''樰棎樕楻梴橙榣桌棭橓槕梉楉森榇棯楯楎椪楝槢楥楰椀榉槄梳楳梜棰楒椧槤樝棭楆檨榤植桞棰楒槡椾極檐桤檒棎楷櫆椅棵椊樥桘模榎榝檀標榢桱棉楅槊槜楩椝棲橅楉棊棐槤樢槵槦橺梔棕棹樄棽歁椬榑樓桽椰欀榩櫎榠榖棎樜榰櫎榯楒楇棰楱槙椧樫棢樚槰楟檢榥楐槙楤樰榖榍椴椟椫榮梺梴樄楉棲'''

bn_fc2_bias_shape = (128,)
bn_fc2_bias = '''憚惹抄憟悭抃慸恖惝挑愳惊慨愩慡愪慴慧愁愘慉慨愭愗懍憷惟憭愙愗憎愨戫护惴慴捃懐惷恛惮慧扎惞慫抏恾捂惹應抵愙惹惫懚恎拡懇憓挂扚懙恖悆慒懰懧憙愳愇抉慨惤惢抅扭憏担愖悊悵惤扭愩捆愻慗愊悲愃挮愊拓懗懶惗抪憡挃憯慫憐慙愬憱慿抻愒憮懴慹拜慉懑懍愵抴成愮慢慆愮戦悷惜扊慍愒'''

fc3_weight_shape = (25, 128)
fc3_weight = '''慂惷懰愸愖懋懍怢悮拂愶愂愚恇愚悰愋愳惢憱慞慙憸惸惕憀悘慬惱急慻悀憸抔慦惴戯懳悉怾愹慄戂悻恠截恿抹悭惁戻恁愽悚戻悳懯惡憮戣懱愑憎恻慇愪愱憔悖愈戠意怼憢慮戊懸戌慽恏恟愈慇愄抙悿憊憒怽愛抱慤扬懍慲愻扷懮憆想慂憐恳憟慫息愦愪愐愷愑憖戈懎憛懓扁懸惝惟慖悶懃惃怹慴惎惶廛徚彅怋忯廚延忖彦弌廰彍彆徻彩形応廾应弒忼廑幱徟忛弉彶徇彜征弩引弌廙徐忻巤彝彔庾式弧幱役忡彞廣帿彵怍帞彝廦廛彥彖形廩庣帛彟廐忺彗徬徂庤忄张弪廓忿張徻彙彀弖幋彝忷态弳庻御弦徺廷彌彛弢庛徱嶩彛廋怘弿廬彥彨忎得廴张忠彃廀弁彘彚徏幛庽忻弓彐彙廿彽忝彛弛店徴徽微彰彔弔怠徆廰恵弱徵恜彠幰廣弁後彴弧廕徃弙往彂徒弁彻息廊弯徨幰忒徸店彫彛巡彟忖忕徻异彵徢徤廐弋怷庸徰并恇弚徬徳循廿弟忼庵忑归彧彲彳怅怡庭忉徂怇徭忮幚弾怯忟廓忐徸徉忌性彔忤怋怢廩彷廪弚徉廀度恀庝庰彃廱庪待廘彃忝徣度徒忍忊弾彣廠弍廹廯庍忯徂恝忝彌復彂復怄廓恋悌彨怍弦忑彺弦广恄彛庿忚徻忉恮忨惜恳恏徵彋忰忳弋忐弛弒怍息庿忈弘廯弝彐彸徑弉恊恫庶弡廗忁怂怤恎彁忪幓恻彸忰廭急怦弻庌开恂彇恆彊怇彾忘徙張怈彯彎悚彄悖忤恊怭待弓彽幰彵廱恶忼怙念悉庀徇怏怒惋恆廯彴彄廪怕弬弝弰律恂心彋庨忬怔徃幔惋幟念忔异忮怋弑徟徏彗怙彳徎彀怖忕惪徾忾彬恡恧怩惆惥惖恣忈悋懠徿恳忂恎必恫忚必忄悚徐恽惘悼徺慥悿忽待恻惧忲忰愿悱怠惕恽恿忹悊怳悶徲悫慅恠戞徭悂慗忿惈惉恏恡惰惷恅愍恏悾悷息恋怛恳恄彳悧悓悪影悗恂慫怞恤怳愚恉惥悒徕愌惃想怌恄悒愖怵懞忯惸怍愕怴慆忴応悁徻恕悚徙慕悻怯愋悂愪恛徢忿惷慕怛怙怙恝怗悠怕悳悓忒惡慪慛愿怵怨憍愞惞扯慒愩憁惫惓憅惫悘慀扛懷惒悺慰惥惃懋慭慼慃懄惟懔懲戕慁慄技扦懰愩恳慳扩惐憪愳懢憃慦慣懘憪愴愹憄慫憐慠惃扪恧扂慘慦恙懳戆恿慭慐惿懢憅恚恂惉慡扠扎惿悓懰懚憷懘愸懮愗慳慉抏愖戡扝懬慔憫惧戼愭愔慕悳憘扟扠慦態恵懗愂憂懎惷愥息抡懔愿惦懁愯愢慎慱愱慇慨庮忠廇庉康廧廌廋弊徵庮弫庩并弯忽徣庣庼庹庩庼彣广废強很廛彅弮康忍徘幬廋帰帳弿彄弡廀弐弡延弩廞彰彊徵应廳庢幙廽帯廽庈廃徒庵康弙張影彆弚徽床庰弛彀彥彷异彉幷弑廔巏彇建彊幔彫廘庙弓幯徭庤庯幻廏庢彠彿弚徯弑开徘徉彤幞待廆弔庬庉彉広幢广廊庵彋康彠弾廹彍徃廱廦徕彉徫待廈弣幌彸微废徊异庖帾弟怗怨徛応念弍廗廴帨廷忖怍式徐弑帢怫弬忡彻庘弣徔廋廷巹忚庸彞彣微帹彮异廿幩巤巾徣巡幥微怿幄弅征帺忲帓彬弥弙忬弼廻帣彖律庞忛弪徒彟応幐徘帿徭後怰异座异幉廆幛帄帏巇彽幡彊弥廛念廰帇建弗彺廊彣嶞帿帙彿弳彫市心嶗巯幛平徧巾帻応怄帻彀巅徏廵嶽平徿幎徆弮廛廖弧弹庒彥弐弶廱怴徳年徟庾徢帴庴廋彸廉徬廄廥徉彨彀御弡徃徺徫幷庴幉彉彽幅庩弓徊弫彖庂怌廸廤徠廼徚幾往忳市彡弮役廦廀忚徍彰归弸弴徻廓庖幄帝弥庹廉廱庱弗廋徆廁彽庛徢帾弘廁弆彆廁弅庐彮彭库彛彶弸徕怦弆彪徒形徖弤庺廌弃廘徼庢巑彯庮後开强廬弟幜広廸徥庶弋庈快幄弆帰幤庳庸彚弒廒弋幡廃彛幨幚彟彻彿弨庅弢彤帐庿徥庌庳復庅廱彀廭庾彭帑彜帩影廒帬幢帘廍弐廚廣庬彑庣庶帖廋帪弻幐弪帔彑帮庬幡度彀庻忭庀弦廁廱幧弈彦幹徏巾弦幕廞弉强彑廟廫彔录弪庬弑庒廓庆弜帾弡弃弛市平庝庯廆彦干幪幟庢後帘庨廣徇彉帺影庇廃廲廻庢忚庫弈幮廬庤庎庪廝憚惢戌懂愠战才慕患懻慫憼懝悤戙愦慶慺悷懴慰懧憊憱扺憶手扆惹憩承懞戕憲慨慵慵慇悺慘慉憗愵戶慦戚悹憅惈扛慩懚憎憄憭懨憡憠惪戭懺愃慷惄慺慲愈戚惪惓懁憊慜愭憆愭慂憋戈惡憏惺懛憁懩慹憕戓惒愔戳懍戧憭愳慗戓慻扫慜愞懪慷懕憘戬戾慫懥愞戟慭扊情憔憱憞惠戂戢或慙惣慨戍戃愿惑幻廝当徴庥弆帲庑廖嶫徏弴忳廾幜廓径庱弚廀幹巑帱弑幸幎平庯彚幽彍庵廘弤庍徽庘径彏开彳录庡帧廴庖忴彾怄微帻庪彛幨怵帰弈弄弡廙徠彜徿忸幯弘彳往彞弃廎忚廓帝廚廨廚巁廈忼幓弢弴徑忂庺徍忥忨弤嶲彲廥态忱彥幢徙幫幱弪彆廝归彥弱弾從彾忲彭帴幟徖怾忥庲忇归应弟徎忆忱徵彴弑廖庀徹庠徠彶忈廾弱往恲徎徵恖忆往從忟忆徔徦廮廥庼忚幗恛恂帋徒恨廛徬怢徽彾录悟惹廤怄徇弽得庤応廥悊忔徦従廴庅徿往彀彤廥張廝徟忡怠彤恝弮徴恎忣彊恈怇廉幽度忍弨弛忓弤徼很忷彼彝彮徃征恉恎忄忰彌弦廧彷廸彘恢庢徯彴悃弱怂徫律庩恝徟恵廒廻嵹怰忰彐彫徘弝廥廙庠弇恃弡怊恈徔彞廋廟怺怰忪恓悑廎徸忷御徾彮弲恣彉忿悖悊怒悾彿弈忮忭怢彺弨弬彯徨彼恕恺弗怗悿彻怞恨忆忴恉弳忭恵悆彪怣忹彻恏彮很廢徻当径恈怴徍忮怼忓弬怰彥恛徨徍徏德忩怓怎張怩悌忄忍張徒忽怶弊恆弬式徒弰彮怚忐忨忊径徚弯征弦悾忼忏彜怆弍忏彁彟応恄彰恁恊弒弋忟恻怓徒徖応忀恴恘恧怆廧廀彭弻彨幐從广廍幠弳弒幏弇帘彟彋徰弼庎庁很幝廘彁帗彣彅幸庹幦弫廩幎廯廲廄幑弉徴彏庨庯廅廁庄录廞幣徴庨彲庯廤弪幈廯彟廦庄廤巬弥弇徧廘帶庡帠廃幘廚廛徭庑帯弱帷廛弊彞帺庒彬廩幢干帖庢弒廘弩弽彼庰徾影弞庹弜庬床彈彂帛帿幋庱彦彻张庍帍庼弰廾庣幁庨弹廂廡巨庍幩庰幠役憡慵悦愆慥慦憜惬惒慢恛愀愊惑戛悀愿愑愩愡憌愳愦慞悟憕憺憅憱憨慕愡扮惤愙憳惙恧憌憋懜惒慠憎扌憊愦惶憼悊憄戩慴悏懆慸慜憬惑慤悼憲才惆悃悑懍惘懻憈戸懥憡慃慬愭慥愲愣愫慅愚愁懩愷懩懽惟憉愖悚憃慞惵懆惪憭懠悏慰慼惘懞愣憮懢怾慏戠慭慅愡戢憴愞憸悺憕懢悓憰想憱懋懌懊扝愌悌惄愝戔悵悿悍悯慙愴悯惲懪愋戅悞憫慧愦惿惓懀惦悛惺慾惃憂愁懂惏惩懾意愅慌懍慖慗恛慭愁悏憹愐憕憋愃應憷憘懘懄惚懂恦惚懐惦愙戗戗憉恎懃慐憯慤慖憋憑惛懲慿愅懥慗惵惺愵惲慘悷悻憽惹懅悀懫惃慎憋悋憁憵恫愆憓悹悧慊憿惎愰懕愳愷憬戦慸憶愮憂戓慒懈惄憗戈愘愙恉戓惆悰感愡戦慊愓怭惛愪恌惉惴慵恂悱怦憊慌愚恪惈悎惹悋惃憍愙慃愺慶惸慰憱慻懋惬懰慍悛慀愵愵慱悰愔愜愄恛憩慵憯慬憉悌恰戎慆恂惹惄慀懕愱惣恂愻惩惾慖愬愹恍愻愸愰愭恳悍憕惚憷悀悓戁悌惖急愐愂惞愒憜愨愤憼恚慚憲憄愲惄慷惷憻惘愾惔憚情惆愙想愯愠懔愆懍憎憾愪惦恅憹愆慓怪慠患慦愲扙愋戜恳惋愛愎惭慙惕慹愮惣悕懙憏憑怣憅慷戔惸惔恼惲愒憘愯戤戤慏悹懘懆憤惀愦懔慥恼愅愻戝惲憋慙憦懓愦惯慍惤慠拁慽愒憤慌慸扝惝懩愘戲慎憆憘愍戻愹愋懿慜愠懨惕手憤戛或悮憀憉悬慛愇懜悸惶懮憳惑憅慕慩惜愰怛慖愽慚憣愄懲憖戫懈惻慿愃慚惘憀懑愠愲惋憼恬愷抬恫愴悓房慉懲愁憚慝弍廖廁帟弧廋庝庖廍廪徫彤布弌廽庝庶彉幌彡張廂幫彄弝彮弗幃廼弼巠弭巅廇幠幓廤廊庁幼巐廏廱彁左庬巜廫幋帲庂庝嵓廪异彋幂廣幣庪巻廄幹幑彿度巳幕巪廨廳幾廛廡庫帹左幐廴巀彍廍底廾嶜州巢建庁庚帗席影彘巼廾幩廇帹廹彟工廞幦廔庋幯店幌幬帶彜廕廈幍幨彝建庽廔庣庯幋彽庄平幠嶯憼惬愗愾愅惓憷悳憌慕愮愦惗愥憧扃憰憐愣愫懭愢慡愴扅悠慒懂懰惲懯憚抙憫愁惝扑懬惃惿慕憌挄惸懅懴憻憳惧户懢悻憕懗扻恼扌慟懑愰戝慯愚憷懅慵憛悅慁惰戇悐懎惏憝懞憁慠慅息慞憿戁想愿悯慄感慛愑扡愉戳懟抚悖憜愠慇懃慎戺拂惟懍慀愊慇扌懄慢懮惂懒懔憒悇愂懆慕恿愌惤愀悾愍懖慸情怽愕惭慈悫懙愐懎悦懕怍悚愪慈戔惜憻憽慹慛惢悶悅憑悱憎慳惸愾悛慗憕憣慈憬慻或愅愬惛慝愔惗愯愚愦惃憇懗懠愇愜憩扑意愂悃惫慱憩惥悎憼慅憄慕悹悹慁悃恱慲戌惹慪憌愞憾懊悑慻愑恬戦憰憧憽惾慐懜愜憬愯慫恛愲懈慝戒感慹戴憷慱慭愬慙慾惯慭惯愉憇恨慩悠悎懚惗悸惻憜慝慑懎惣惰愛愪愭悯惾憗戵慷慄惠懫恣憄恰愶惥憼悪慌悂戛慓愫惫懆悥恙惝憱悎愤慉應慈愅憄愺惽懲悂懪悓憕惾惝戋憤愻愗戭慖憁憸惣戼愧戶惯愣懍惓愝惵惲悏悏愢愼愌愇恶慅愢悸懶憸恸愱悶愑怛愶恑愱惥悿懀慺惍憰憸懇憄憭慭慉懷憾悤憬愎戟憴憩悏慭悏惘憗愃惣憻憚悩慰恣慎悅憹悠惰慩愹慥慃懫憇憔憝憇恕愑悒愼戆憊憋惽悠恪悝惉慴憒慳愦憇惴憛悢悾憭慕悊慱憞懃怙愠懣憓慾恻悪戇惉懓恾憥惒慵憣憅惎悢惤憣戎懖憦憕慨戔恋懙慍戏悅懬憐懊愕惦慠憛憏惦懼慶憎悧慹愹憃惏憰惴悽愋慴慲慷愿悭慥愧悊慨惆憛惣慌懢慁愬慮愼憻恲愀戭慾悾慨愀慎愥慰惣惕悱懒慓憚慾憿憴恞恏恽悭悬怹情懂愅巻弗庁幌庅帵嶤廲彉并帟彅廯彏彧帲彈庻廀彫帘帊廍幱幟库彤帮弘庫幷廻廛幺庁庋廙庻廉弿廜庞幾廋庳帛強師庒嶪弁廟巰弴年径嶯幮幀弙庽廛弴度師幣庘庛彜彪廇彀弉彠弞廅幚左庭幎廦庩徃廬帾彞彴弉彽序巛庍弲弭廩徤廡弨帽序幆幪帶幸幀庈弇徊巎帲建廲廴弆廋彞形廢廻庲廄弉廯弈弸床彅彞'''

fc3_bias_shape = (25,)
fc3_bias = '''懡徰徘徾忂惢幠彵彟巡懩彛彴怿廔憹憧愨懷巙慹憆憸懪幱'''



class Conv2D_Numpy:
    def __init__(self, in_channels, out_channels, kernel_size,
                 stride=1, padding='valid', dilation=1, bias=True):
        self.in_channels = in_channels
        self.out_channels = out_channels

        if isinstance(kernel_size, int):
            self.kernel_size = (kernel_size, kernel_size)
        else:
            self.kernel_size = kernel_size
        if isinstance(stride, int):
            self.stride = (stride, stride)
        else:
            self.stride = stride
        if isinstance(dilation, int):
            self.dilation = (dilation, dilation)
        else:
            self.dilation = dilation

        self.padding = padding
        self.use_bias = bias

        kh, kw = self.kernel_size
        # dilation effect on kernel size
        self.kh_dil = self.dilation[0] * (kh - 1) + 1
        self.kw_dil = self.dilation[1] * (kw - 1) + 1

        fan_in = in_channels * kh * kw
        scale = np.sqrt(1. / fan_in)
        self.weight = np.random.uniform(-scale, scale,
                                        (out_channels, in_channels, kh, kw))
        self.bias = np.random.uniform(-scale, scale, out_channels) if bias else None

    def pad_input(self, x, pad_top, pad_bottom, pad_left, pad_right):
        return np.pad(x, ((0, 0), (0, 0), (pad_top, pad_bottom), (pad_left, pad_right)), mode='constant')

    def im2col(self, x, out_h, out_w):
        N, C, H, W = x.shape
        kh, kw = self.kernel_size
        sh, sw = self.stride
        dh, dw = self.dilation

        # Calculate the size of each patch with dilation
        kh_dil = self.kh_dil
        kw_dil = self.kw_dil

        cols = np.zeros((N, C, kh, kw, out_h, out_w), dtype=x.dtype)

        for y in range(kh):
            y_max = y * dh + sh * out_h
            for x_ in range(kw):
                x_max = x_ * dw + sw * out_w
                cols[:, :, y, x_, :, :] = x[:, :, y * dh:y_max:sh, x_ * dw:x_max:sw]

        # Rearrange so that each patch is flattened in last dim
        cols = cols.transpose(0, 4, 5, 1, 2, 3).reshape(N * out_h * out_w, -1)  # shape (N*out_h*out_w, C*kh*kw)
        return cols

    def forward(self, x):
        N, C, H, W = x.shape
        sh, sw = self.stride

        # Compute output size and padding
        if self.padding == 'same':
            out_h = int(np.ceil(H / sh))
            out_w = int(np.ceil(W / sw))

            pad_h = max((out_h - 1) * sh + self.kh_dil - H, 0)
            pad_w = max((out_w - 1) * sw + self.kw_dil - W, 0)

            pad_top = pad_h // 2
            pad_bottom = pad_h - pad_top
            pad_left = pad_w // 2
            pad_right = pad_w - pad_left

            x_padded = self.pad_input(x, pad_top, pad_bottom, pad_left, pad_right)
        elif self.padding == 'valid':
            out_h = (H - self.kh_dil) // sh + 1
            out_w = (W - self.kw_dil) // sw + 1
            x_padded = x
        else:
            raise ValueError("Only 'same' or 'valid' padding supported")

        # Extract patches
        col = self.im2col(x_padded, out_h, out_w)  # (N*out_h*out_w, C*kh*kw)
        # Reshape weights to (out_channels, C*kh*kw)
        weight_col = self.weight.reshape(self.out_channels, -1)  # (out_channels, C*kh*kw)

        # Matrix multiplication + bias
        out = col @ weight_col.T  # shape (N*out_h*out_w, out_channels)
        if self.use_bias:
            out += self.bias

        # Reshape output to (N, out_channels, out_h, out_w)
        out = out.reshape(N, out_h, out_w, self.out_channels).transpose(0, 3, 1, 2)

        return out


   

def adaptive_avg_pool2d_numpy(x, output_size):
    """
    Simule torch.nn.AdaptiveAvgPool2d en NumPy.
    
    Args:
        x: Tensor NumPy de forme (N, C, H_in, W_in)
        output_size: int ou tuple (H_out, W_out)
    
    Returns:
        Tensor NumPy de forme (N, C, H_out, W_out)
    """
    if isinstance(output_size, int):
        output_size = (output_size, output_size)
    H_out, W_out = output_size

    N, C, H_in, W_in = x.shape
    out = np.zeros((N, C, H_out, W_out), dtype=x.dtype)

    for i in range(H_out):
        h_start = int(np.floor(i * H_in / H_out))
        h_end = int(np.ceil((i + 1) * H_in / H_out))
        for j in range(W_out):
            w_start = int(np.floor(j * W_in / W_out))
            w_end = int(np.ceil((j + 1) * W_in / W_out))
            patch = x[:, :, h_start:h_end, w_start:w_end]
            out[:, :, i, j] = patch.mean(axis=(2, 3))
    
    return out

import numpy as np

class Linear:
    def __init__(self, in_features, out_features, bias=True):
        self.in_features = in_features
        self.out_features = out_features
        self.bias_enabled = bias
        
        # Initialisation uniforme U(-k, k) avec k = 1 / sqrt(in_features)
        k = 1 / np.sqrt(in_features)
        self.weight = np.random.uniform(-k, k, size=(out_features, in_features)).astype(np.float32)
        if bias:
            self.bias = np.random.uniform(-k, k, size=(out_features,)).astype(np.float32)
        else:
            self.bias = None

    def __call__(self, x):
        return self.forward(x)

    def forward(self, x):
        # x shape: (..., in_features)
        y = x @ self.weight.T  # shape: (..., out_features)
        if self.bias_enabled:
            y += self.bias
        return y

class BatchNorm1d:
    def __init__(self, num_features, eps=1e-5, momentum=0.1, affine=True, track_running_stats=True):
        self.num_features = num_features
        self.eps = eps
        self.momentum = momentum
        self.affine = affine
        self.track_running_stats = track_running_stats

        self.gamma = np.ones(num_features) if affine else None
        self.beta = np.zeros(num_features) if affine else None

        self.running_mean = np.zeros(num_features) if track_running_stats else None
        self.running_var = np.ones(num_features) if track_running_stats else None

        self.training = True

    def train(self):
        self.training = True

    def eval(self):
        self.training = False

    def forward(self, x):
        x = np.asarray(x)
        if x.shape[-1] != self.num_features:
            raise ValueError(f"Expected last dimension to be {self.num_features}, got {x.shape[-1]}")

        # Calcul mean et var sur tous les axes sauf le dernier (feature)
        axes = tuple(i for i in range(x.ndim - 1))  # ex: (0,) pour 2D, (0,1) pour 3D

        mean = np.mean(x, axis=axes, keepdims=True)  # shape compatible pour broadcast
        var = np.var(x, axis=axes, ddof=0, keepdims=True)

        x_hat = (x - mean) / np.sqrt(var + self.eps)

        if self.affine:
            # gamma et beta doivent être broadcastables sur x_hat
            # gamma, beta ont shape (C,), on reshape en (1, 1, ..., C) selon ndim de x
            shape = [1] * x.ndim
            shape[-1] = self.num_features
            gamma = self.gamma.reshape(shape)
            beta = self.beta.reshape(shape)
            x_hat = x_hat * gamma + beta

        return x_hat


    def __call__(self, x):
        return self.forward(x)


import numpy as np

class BatchNorm2d:
    def __init__(self, num_features, eps=1e-5, momentum=0.1, affine=True, track_running_stats=True):
        self.num_features = num_features
        self.eps = eps
        self.momentum = momentum
        self.affine = affine
        self.track_running_stats = track_running_stats

        # Paramètres appris (gamma et beta)
        self.gamma = np.ones((1, num_features, 1, 1)) if affine else None
        self.beta = np.zeros((1, num_features, 1, 1)) if affine else None

        # Moyenne et variance courantes (estimées pendant l'entraînement)
        self.running_mean = np.zeros((1, num_features, 1, 1)) if track_running_stats else None
        self.running_var = np.ones((1, num_features, 1, 1)) if track_running_stats else None

        self.training = True

    def train(self):
        self.training = True

    def eval(self):
        self.training = False

    def forward(self, x):
        if x.ndim != 4 or x.shape[1] != self.num_features:
            raise ValueError(f"Expected input of shape (N, {self.num_features}, H, W), got {x.shape}")

        # Moyenne et variance sur (N, H, W) pour chaque canal C
        mean = np.mean(x, axis=(0, 2, 3), keepdims=True)  # shape (1, C, 1, 1)
        var = np.var(x, axis=(0, 2, 3), ddof=0, keepdims=True)

        x_hat = (x - mean) / np.sqrt(var + self.eps)

        if self.affine:
            # reshape pour broadcast (C,) → (1, C, 1, 1)
            gamma = self.gamma.reshape(1, -1, 1, 1)
            beta = self.beta.reshape(1, -1, 1, 1)
            x_hat = x_hat * gamma + beta

        return x_hat


    def __call__(self, x):
        return self.forward(x)


class PolicyNet_Numpy:
    def __init__(self, num_players=5, num_actions=5):
        self.num_players = num_players
        self.num_actions = num_actions

        self.conv1 = Conv2D_Numpy(in_channels=93, out_channels=8, kernel_size=3, padding='same')
        self.conv2 = Conv2D_Numpy(in_channels=8, out_channels=16, kernel_size=3, padding='same')
        self.conv3 = Conv2D_Numpy(in_channels=16, out_channels=16, kernel_size=3, padding='same')

        self.fc1 = Linear(in_features=16, out_features=64)
        self.fc2 = Linear(in_features=64, out_features=128)
        self.fc3 = Linear(in_features=128, out_features=num_players * num_actions)

    def relu(self, x):
        return np.maximum(0, x)

    def eval(self):
        pass

    def forward(self, x):
        x = self.relu(self.conv1.forward(x))
        x = self.relu(self.conv2.forward(x))
        x = self.relu(self.conv3.forward(x))

        x = adaptive_avg_pool2d_numpy(x, output_size=1)  # shape: (B, 16, 1, 1)
        x = x.reshape(x.shape[0], -1)  # shape: (B, 16)

        x = self.relu(self.fc1.forward(x))  # shape: (B, 64)
        x = self.relu(self.fc2.forward(x))
        x = self.fc3.forward(x)             # shape: (B, num_players * num_actions)

        return x.reshape(-1, self.num_players, self.num_actions)


def softmax(x, axis=-1):
    # Soustrait le max pour éviter l'overflow numérique
    x = x - np.max(x, axis=axis, keepdims=True)
    exp_x = np.exp(x)
    return exp_x / np.sum(exp_x, axis=axis, keepdims=True)


# 2. Multinomial sampling
def multinomial_numpy(probs):
    """
    Simule torch.multinomial(probs, num_samples=1).squeeze(1)
    Args:
        probs: np.ndarray of shape (batch, num_classes)
    Returns:
        np.ndarray of shape (batch,)
    """
    batch_size, num_classes = probs.shape
    samples = np.array([
        np.random.choice(num_classes, p=probs[i])
        for i in range(batch_size)
    ])
    return samples

def decode_unicode_string_to_weights(unicode_str, offset=12.0, divider=2048.0, shape=None):
	# Étape 1 : reconstruire la chaîne binaire 'weights_bytes' comme en C++ wstring -> string
	weights_bytes = bytearray()
	for c in unicode_str:
		val = ord(c)
		weights_bytes.append((val >> 8) & 0xFF)  # octet haut
		weights_bytes.append(val & 0xFF)         # octet bas

	# Étape 2 : lire les poids 2 octets par 2 octets, big-endian
	size = len(weights_bytes) // 2
	output = []
	for i in range(size):
		s1 = weights_bytes[2*i]
		s2 = weights_bytes[2*i + 1]
		s = (s1 << 8) + s2
		val = (s / divider) - offset
		output.append(val)

	# Étape 3 : si shape précisé, reshape en numpy array
	if shape is not None:
		import numpy as np
		output = np.array(output, dtype=np.float32).reshape(shape)
	else:
		output = list(output)

	return output


class Coord:
	def __init__(self, x, y):
		self.x = x
		self.y = y

	def euclidean_to(self, x, y):
		return ((x - self.x) ** 2 + (y - self.y) ** 2) ** 0.5

	def sqr_euclidean_to(self, x, y):
		return (x - self.x) ** 2 + (y - self.y) ** 2

	def add(self, x, y=None):
		if y is None:
			x, y = x.x, x.y
		return Coord(self.x + x, self.y + y)

	def __hash__(self):
		return hash((self.x, self.y))

	def __eq__(self, other):
		return isinstance(other, Coord) and self.x == other.x and self.y == other.y

	def __repr__(self):
		return f"({self.x}, {self.y})"

	def to_int_string(self):
		return f"{self.x} {self.y}"

	def get_x(self):
		return self.x

	def get_y(self):
		return self.y

	def manhattan_to(self, other):
		if isinstance(other, Coord):
			return abs(self.x - other.x) + abs(self.y - other.y)
		x, y = other
		return abs(self.x - x) + abs(self.y - y)

	def chebyshev_to(self, other):
		if isinstance(other, Coord):
			return max(abs(self.x - other.x), abs(self.y - other.y))
		x, y = other
		return max(abs(self.x - x), abs(self.y - y))


class Tile:
	TYPE_FLOOR = 0
	TYPE_LOW_COVER = 1
	TYPE_HIGH_COVER = 2

	def __init__(self, coord, type_=TYPE_FLOOR):
		self.coord = coord
		self.type = type_

	def set_type(self, type_):
		self.type = type_

	def get_type(self):
		return self.type

	def is_cover(self):
		return self.type != Tile.TYPE_FLOOR

	def get_cover_modifier(self):
		if self.type == Tile.TYPE_LOW_COVER:
			return 0.5
		elif self.type == Tile.TYPE_HIGH_COVER:
			return 0.25
		return 1

	def clear(self):
		self.type = Tile.TYPE_FLOOR

	def is_valid(self):
		# Should compare with a NO_TILE instance
		return True

class Player:
	def __init__(self, coord, team):
		self.coord = coord  # Un objet Coord
		self.team = team    # "red" ou "blue"
		self.last_coord = coord
		self.mx_cooldown = random.randint(5, 7)
		self.cooldown = 0
		self.splash_bombs = random.randint(0, 3)
		self.wetness = 0   
		self.optimalRange = random.randint(5, 10)
		self.soakingPower = random.randint(10, 25)
		self.score = 0
		self.dead = 0
		self.thx = -1
		self.thy = -1
		self.id = 0
		self.idsh = -1

	def move(self, c):
		self.last_coord = self.coord
		self.coord = c

	def back_move(self):
		self.coord = self.last_coord

	def __repr__(self):
		return f"Player({self.coord}, '{self.team}')"


def encode_players_numpy(players, grid_height, grid_width,g):
	# On utilise 8 canaux par joueur (comme dans ton code PyTorch)
	# cooldown, bombs, wetness, range, power, is_red, is_blue, dead
	tensor = np.zeros((45, grid_height, grid_width), dtype=np.float32)

	base = 0
	for player in players:
		x, y = player.coord.x, player.coord.y

		# évite les débordements hors grille
		if 0 <= x < grid_width and 0 <= y < grid_height:
			tensor[base + 0, y, x] = player.cooldown / player.mx_cooldown
			tensor[base + 1, y, x] = player.splash_bombs / 3.0
			tensor[base + 2, y, x] = player.wetness / 100.0
			tensor[base + 3, y, x] = (player.optimalRange - 5) / 5.0
			tensor[base + 4, y, x] = (player.soakingPower - 10) / 15.0

			if player.team == "red":
				tensor[base + 5, y, x] = 1.0
			elif player.team == "blue":
				tensor[base + 6, y, x] = 1.0

			tensor[base + 7, y, x] = player.dead
			score = g.rscore if players[0].team == 'red' else game.bscore
			tensor[base + 8, y, x] = score / 1500.0

			base += 9

	return tensor  # shape : (40, H, W)


def encode_grid_numpy(grid,w, h):
	tensor = np.zeros((3, 10, 20), dtype=np.float32)

	print(w, h, my_color, file=sys.stderr, flush=True)
	for y in range(h):
		for x in range(w):
			t = grid[y][x]
			if t == Tile.TYPE_FLOOR:
				tensor[0, y, x] = 1.0
			elif t == Tile.TYPE_LOW_COVER:
				tensor[1, y, x] = 1.0
			elif t == Tile.TYPE_HIGH_COVER:
				tensor[2, y, x] = 1.0

	return tensor  # shape : (3, 20, 10)


def create_dead_player(coord, team):
	p = Player(coord, team)
	p.cooldown = 0
	p.mx_cooldown = 1
	p.splash_bombs = 0
	p.wetness = 0
	p.optimalRange = 0
	p.soakingPower = 0
	p.score = 0
	p.dead = 1
	return p


def complete_team(players, team, n=5):
	# Garde les joueurs vivants
	players_completed = players.copy()
	
	# Calcule combien il manque de joueurs
	missing = n - len(players)
	
	# Ajoute les joueurs morts manquants
	if missing > 0:
		dead_players = [
			create_dead_player(Coord(-1, -1), team)
			for _ in range(missing)
		]
		players_completed.extend(dead_players)
	
	return players_completed

def encode_ALL_RL_numpy(grid, red, blue, w, h, g):
	red_complete = complete_team(red, "red", 5)
	blue_complete = complete_team(blue, "blue", 5)

	tensor_red = encode_players_numpy(red_complete, 10, 20,g)   # (40, 20, 10)
	tensor_blue = encode_players_numpy(blue_complete, 10, 20,g) # (40, 20, 10)
	tensor_grid = encode_grid_numpy(grid, w, h)                     # (3, 20, 10)

	# concaténation sur l'axe des canaux (axis=0)
	input_tensor = np.concatenate([tensor_red, tensor_blue, tensor_grid], axis=0) 
	return input_tensor  # shape: (40+40+3=83, 20, 10)


class Game:

	def __init__(self, w, h):
		self.width = w
		self.height = h
		self.grid = grid
		self.red = []
		self.blue = []
		self.rscore = 0
		self.bscore = 0
		self.my_color = my_color
		self.IDME = {}
		self.IDOPP = {}
		self.state = {}

	def init_NNUSNW(self):
		self.nnz = PolicyNet_Numpy(num_players=5, num_actions=5)

		# Conv1
		conv1_weight_ = decode_unicode_string_to_weights(conv1_weight, shape=conv1_weight_shape)
		self.nnz.conv1.weight = conv1_weight_

		conv1_bias_ = decode_unicode_string_to_weights(conv1_bias, shape=conv1_bias_shape)
		self.nnz.conv1.bias = conv1_bias_

		# Conv2
		conv2_weight_ = decode_unicode_string_to_weights(conv2_weight, shape=conv2_weight_shape)
		self.nnz.conv2.weight = conv2_weight_

		conv2_bias_ = decode_unicode_string_to_weights(conv2_bias, shape=conv2_bias_shape)
		self.nnz.conv2.bias = conv2_bias_

		# Conv3
		conv3_weight_ = decode_unicode_string_to_weights(conv3_weight, shape=conv3_weight_shape)
		self.nnz.conv3.weight = conv3_weight_

		conv3_bias_ = decode_unicode_string_to_weights(conv3_bias, shape=conv3_bias_shape)
		self.nnz.conv3.bias = conv3_bias_

		# Fully connected
		fc1_weight_ = decode_unicode_string_to_weights(fc1_weight, shape=fc1_weight_shape)
		self.nnz.fc1.weight = fc1_weight_

		fc1_bias_ = decode_unicode_string_to_weights(fc1_bias, shape=fc1_bias_shape)
		self.nnz.fc1.bias = fc1_bias_

		fc2_weight_ = decode_unicode_string_to_weights(fc2_weight, shape=fc2_weight_shape)
		self.nnz.fc2.weight = fc2_weight_

		fc2_bias_ = decode_unicode_string_to_weights(fc2_bias, shape=fc2_bias_shape)
		self.nnz.fc2.bias = fc2_bias_

		fc3_weight_ = decode_unicode_string_to_weights(fc3_weight, shape=fc3_weight_shape)
		self.nnz.fc3.weight = fc3_weight_

		fc3_bias_ = decode_unicode_string_to_weights(fc3_bias, shape=fc3_bias_shape)
		self.nnz.fc3.bias = fc3_bias_
		

	def Play(self, ind):

		ARG_MAX = False

		directions = [Coord(1, 0), Coord(-1, 0), Coord(0, 1), Coord(0, -1)]

		occupied = set(p.coord for p in self.red + self.blue)
		self.action = []

		
		# state_tensor_batch shape: (1, 83, 20, 10) par exemple
		self.nnz.eval()
		player = self.red if ind == 'red' else self.blue
		player2 = self.blue if ind == 'red' else self.red
		state_tensor = encode_ALL_RL_numpy(self.grid, player, player2, self.width, self.height, self)  # (canaux, H, W)

		# Ajouter une dimension batch au début : shape devient (1, canaux, H, W)
		state_tensor_batch = np.expand_dims(state_tensor, axis=0)

		# Passage dans le réseau numpy
		logits = self.nnz.forward(state_tensor_batch)  # shape (1, num_players, num_actions)

		# Supprimer la dimension batch pour avoir (num_players, num_actions)
		logits = np.squeeze(logits, axis=0)

		probs = softmax(logits, axis=-1)
		actions = multinomial_numpy(probs)
		actions_list = actions.tolist()

		#print("Actions pr�dites par joueur :", actions_list)

		if ind == 'red':
			
			# Actions des rouges uniquement
			for i, p in enumerate(self.red):
				if actions_list[i] == 4:continue
				origin = Coord(p.coord.x, p.coord.y)
				mv = origin.add(directions[actions_list[i]])
				if mv.x < 0 or mv.x >= self.width or mv.y < 0 or mv.y >= self.height:continue
				t = self.grid[mv.y][mv.x]
				if t != Tile.TYPE_FLOOR: continue
				if mv not in occupied:
					p.move(mv)
				
			

			# Pour les bleus on n�ajoute rien dans self.action,
			# ou on ajoute une action neutre si tu veux toujours m�me taille

		else:
			
			# Actions des rouges uniquement
			for i, p in enumerate(self.blue):
				if actions_list[i] == 4:continue
				origin = Coord(p.coord.x, p.coord.y)
				mv = origin.add(directions[actions_list[i]])
				if mv.x < 0 or mv.x >= self.width or mv.y < 0 or mv.y >= self.height:continue
				t = self.grid[mv.y][mv.x]
				if t != Tile.TYPE_FLOOR: continue
				if mv not in occupied:
					p.move(mv)


		# Correction position conflictuelle / retour arri�re
		# Note: ici, self.action a autant d��l�ments que de joueurs concern�s (rouges ou bleus)
		players = self.red if ind == 'red' else self.blue
		for idx, p in enumerate(players):
			occupied = set(pl.coord for pl in self.red + self.blue if pl != p)
			if p.coord in occupied:
				p.back_move()


		if ind == 'red':

			for p in self.red:
				if p.splash_bombs > 0:
					zones = self.get_best_zone_for_agent(p, self.red, self.blue, width=self.width, height=self.height)
					if len(zones) > 0:
						p.thx, p.thy = zones[0]
						p.splash_bombs-= 1

					else:
						p.txh, p.thy = -1, -1
				else:
					p.txh, p.thy = -1, -1

		else:

			for p in self.blue:
				if p.splash_bombs > 0:
					zones = self.get_best_zone_for_agent(p, self.blue, self.red, width=self.width, height=self.height)
					if len(zones) > 0:
						p.thx, p.thy = zones[0]
						p.splash_bombs-= 1
						
					else:
						p.txh, p.thy = -1, -1
				else:
					p.txh, p.thy = -1, -1

		self.Shoot(ind)
				
		players = self.red if ind == 'red' else self.blue
		for p in players:
			shoot = ''
			if p.thx != -1:
				shoot = 'THROW ' + str(p.thx) + ' ' + str(p.thy) 
			elif p.idsh != -1:
				shoot = 'SHOOT ' + str(p.idsh)
			else:
				shoot = 'HUNKER_DOWN'
			print(f"{p.id}; MOVE {p.coord.x} {p.coord.y};" + shoot)

	def get_cover_modifier(self, target, shooter):
		dx = target.coord.x - shooter.coord.x
		dy = target.coord.y - shooter.coord.y
		best_modifier = 1.0

		for d in [(dx, 0), (0, dy)]:
			if abs(d[0]) > 1 or abs(d[1]) > 1:
				adj_x = -int(math.copysign(1, d[0])) if d[0] != 0 else 0
				adj_y = -int(math.copysign(1, d[1])) if d[1] != 0 else 0

				cover_pos = Coord(target.coord.x + adj_x, target.coord.y + adj_y)

				if cover_pos.chebyshev_to(shooter.coord) > 1:
					tile = self.grid.get(cover_pos.x, cover_pos.y)
					best_modifier = min(best_modifier, tile.get_cover_modifier())

		return best_modifier

	def Shoot(self, rb):
		team1 = self.red if rb == 'red' else self.blue
		team2 = self.blue if rb == 'red' else self.red

		for pr in team1:
			if pr.cooldown != 0:
				pr.idsh = -1
				continue
			if pr.thx != -1: continue
			idx = -1
			maxsh = -20000000
			for i, pb in enumerate(team2):
				dsh = pr.coord.manhattan_to(pb.coord)
				if dsh <= self.state[pr.id].optimalRange*2:
					if pb.wetness > maxsh:
						maxsh = pb.wetness
						idx = pb.id

			if idx != -1:
				pr.idsh = idx
			else:
				pr.idsh = -1
		
	def get_neighbors_around(self, cx, cy, players):
		neighbors = []
		for p in players:
			px, py = p.coord.x, p.coord.y
			if abs(px - cx) <= 1 and abs(py - cy) <= 1:
				if not (px == cx and py == cy):  # Exclure le centre
					neighbors.append(p)
		return neighbors

	def get_best_zone_for_agent(self, agent: Player, my_agents: list[Player], opp_agents: list[Player], width: int, height: int):
		best_zones = []
		max_enemy_score = -1

		directions = [(0, -1), (-1, 0), (1, 0), (0, 1)]

		for dy in range(-4, 5):
			for dx in range(-4, 5):
				cx = agent.coord.x + dx
				cy = agent.coord.y + dy

				if abs(dx) + abs(dy) > 4:
					continue

				if cx < 0 or cx >= width or cy < 0 or cy >= height:
					continue

				# V�rifie que cette case n�est pas trop proche d�un co�quipier (sauf soi-m�me)
				too_close_to_ally = False
				for ally in my_agents:
					if ally is agent:
						continue
					if abs(ally.coord.x - cx) <= 1 and abs(ally.coord.y - cy) <= 1:
						too_close_to_ally = True
						break

				if too_close_to_ally:
					continue

				adjacent_enemies = 0
				enemy_score = 0

				for dx_dir, dy_dir in directions:
					ex = cx + dx_dir
					ey = cy + dy_dir

					for opp in opp_agents:
						if opp.coord.x == ex and opp.coord.y == ey:
							adjacent_enemies += 1
							enemy_score += 10
							enemy_score += opp.splash_bombs * 10 + (opp.wetness + 30) * 1000
							break

				if adjacent_enemies > 0:
					if enemy_score > max_enemy_score:
						max_enemy_score = enemy_score
						best_zones = [(cx, cy)]
					elif enemy_score == max_enemy_score:
						best_zones.append((cx, cy))

		return best_zones

# Win the water fight by controlling the most territory, or out-soak your opponent!

my_id = int(input())  # Your player id (0 or 1)
agent_data_count = int(input())  # Total number of agents in the game
stat={}
IDME={}
IDOPP={}
for i in range(agent_data_count):
	# agent_id: Unique identifier for this agent
	# player: Player id of this agent
	# shoot_cooldown: Number of turns between each of this agent's shots
	# optimal_range: Maximum manhattan distance for greatest damage output
	# soaking_power: Damage output within optimal conditions
	# splash_bombs: Number of splash bombs this can throw this game
	agent_id, player, shoot_cooldown, optimal_range, soaking_power, splash_bombs = [int(j) for j in input().split()]

	p = Player(Coord(-1, -1), 'red')
	p.mx_cooldown = shoot_cooldown
	p.optimalRange = optimal_range
	p.soakingPower = soaking_power
	p.splash_bombs = splash_bombs
	stat[agent_id] = p
	
	if player == my_id:
		IDME[agent_id] = agent_id
	else:
		IDOPP[agent_id] = agent_id



# width: Width of the game map
# height: Height of the game map
width, height = [int(i) for i in input().split()]
grid = []
for i in range(height):
    inputs = input().split()
    l = []
    for j in range(width):
        # x: X coordinate, 0 is left edge
        # y: Y coordinate, 0 is top edge
        x = int(inputs[3*j])
        y = int(inputs[3*j+1])
        tile_type = int(inputs[3*j+2])
        l.append(tile_type)
    grid.append(l)

turn = 0
my_color = ''
opp_color = ''

game = Game(width, height)
game.grid = grid
game.init_NNUSNW()
game.IDME = IDME
game.IDOPP = IDOPP
game.state = stat
# game loop
while True:
	agent_count = int(input())  # Total number of agents still in the game
	redi={}
	bluei={}
	red=[]
	blue=[]
	for i in range(agent_count):
		# cooldown: Number of turns before this agent can shoot
		# wetness: Damage (0-100) this agent has taken
		agent_id, x, y, cooldown, splash_bombs, wetness = [int(j) for j in input().split()]

		if agent_id in IDME:
			# C'est moi
			if turn == 0:
				if x == 0:
					my_color = 'red'
					opp_color = 'blue'
				else:
					my_color = 'blue'
					opp_color = 'red'

			p = Player(Coord(x, y), my_color)
			p.id = agent_id
			p.cooldown = cooldown
			p.splash_bombs = splash_bombs
			p.wetness = wetness

			if my_color == 'red':
				red.append(p)
			else:
				blue.append(p)
		else:
			# Ennemi
			if turn == 0:
				if x == 0:
					my_color = 'blue'
					opp_color = 'red'
				else:
					my_color = 'red'
					opp_color = 'blue'

			p = Player(Coord(x, y), opp_color)
			p.id = agent_id
			p.cooldown = cooldown
			p.splash_bombs = splash_bombs
			p.wetness = wetness

			if opp_color == 'red':
				red.append(p)
			else:
				blue.append(p)



	game.my_color = my_color
	game.red = red
	game.blue = blue

	my_count = 0
	opp_count = 0

	for y in range(height):
		for x in range(width):
			best_dist1 = float('inf')
			best_dist2 = float('inf')

			for a in game.red:
				da = abs(y - a.coord.y) + abs(x - a.coord.x)
				if a.wetness >= 50:
					da *= 2
				best_dist1 = min(best_dist1, da)

			for a in game.blue:
				da = abs(y - a.coord.y) + abs(x - a.coord.x)
				if a.wetness >= 50:
					da *= 2
				best_dist2 = min(best_dist2, da)

			if best_dist1 < best_dist2:
				my_count += 1
			elif best_dist2 < best_dist1:
				opp_count += 1

	r = my_count - opp_count
	if r > 0:
		game.rscore += r
	else:
		game.bscore += -r



	print("my_color=", my_color, file=sys.stderr, flush=True)

	my_agent_count = int(input())  # Number of alive agents controlled by you
	game.Play(my_color)

	turn += 1